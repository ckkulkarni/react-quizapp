53a9f8af4cede9340eccdb9c2b5cab97
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
// @ts-nocheck
const react_1 = __importDefault(require("react"));
const prop_types_1 = __importDefault(require("prop-types"));
const RootFinder_1 = __importDefault(require("./RootFinder"));
const stringOrFunction = prop_types_1.default.oneOfType([prop_types_1.default.func, prop_types_1.default.string]);
const makeValidElementType = adapter => {
  if (!adapter) {
    return stringOrFunction;
  }
  function validElementTypeRequired(props, propName, ...args) {
    if (!adapter.isValidElementType) {
      return stringOrFunction.isRequired(props, propName, ...args);
    }
    const propValue = props[propName];
    if (adapter.isValidElementType(propValue)) {
      return null;
    }
    return new TypeError(`${propName} must be a valid element type!`);
  }
  function validElementType(props, propName, ...args) {
    const propValue = props[propName];
    if (propValue == null) {
      return null;
    }
    return validElementTypeRequired(props, propName, ...args);
  }
  validElementType.isRequired = validElementTypeRequired;
  return validElementType;
};
/**
 * This is a utility component to wrap around the nodes we are
 * passing in to `mount()`. Theoretically, you could do everything
 * we are doing without this, but this makes it easier since
 * `renderIntoDocument()` doesn't really pass back a reference to
 * the DOM node it rendered to, so we can't really "re-render" to
 * pass new props in.
 */
function createMountWrapper(node, options = {}) {
  const {
    adapter,
    wrappingComponent: WrappingComponent
  } = options;
  class WrapperComponent extends react_1.default.Component {
    constructor(...args) {
      super(...args);
      const {
        props,
        wrappingComponentProps,
        context
      } = this.props;
      this.state = {
        mount: true,
        props,
        wrappingComponentProps,
        context
      };
    }
    setChildProps(newProps, newContext, callback = undefined) {
      const {
        props: oldProps,
        context: oldContext
      } = this.state;
      const props = {
        ...oldProps,
        ...newProps
      };
      const context = {
        ...oldContext,
        ...newContext
      };
      this.setState({
        props,
        context
      }, callback);
    }
    setWrappingComponentProps(props, callback = undefined) {
      this.setState({
        wrappingComponentProps: props
      }, callback);
    }
    render() {
      const {
        Component,
        refProp
      } = this.props;
      const {
        mount,
        props,
        wrappingComponentProps
      } = this.state;
      if (!mount) return null;
      const component = react_1.default.createElement(Component, {
        ref: refProp,
        ...props
      });
      if (WrappingComponent) {
        return react_1.default.createElement(WrappingComponent, {
          ...wrappingComponentProps
        }, react_1.default.createElement(RootFinder_1.default, null, component));
      }
      return component;
    }
    componentDidMount() {
      const {
        onRenderCb
      } = this.props;
      onRenderCb && onRenderCb(this);
    }
  }
  WrapperComponent.propTypes = {
    Component: makeValidElementType(adapter).isRequired,
    context: prop_types_1.default.object,
    props: prop_types_1.default.object.isRequired,
    refProp: prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.func, prop_types_1.default.shape({
      current: prop_types_1.default.any
    })]),
    wrappingComponentProps: prop_types_1.default.object
  };
  WrapperComponent.defaultProps = {
    refProp: null,
    context: null,
    wrappingComponentProps: null
  };
  if (options.context && (node.type.contextTypes || options.childContextTypes)) {
    // For full rendering, we are using this wrapper component to provide context if it is
    // specified in both the options AND the child component defines `contextTypes` statically
    // OR the merged context types for all children (the node component or deeper children) are
    // specified in options parameter under childContextTypes.
    // In that case, we define both a `getChildContext()` function and a `childContextTypes` prop.
    const childContextTypes = {
      ...node.type.contextTypes,
      ...options.childContextTypes
    };
    WrapperComponent.prototype.getChildContext = function getChildContext() {
      return this.state.context;
    };
    WrapperComponent.childContextTypes = childContextTypes;
  }
  return WrapperComponent;
}
exports.default = createMountWrapper;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJyZWFjdF8xIiwicmVxdWlyZSIsInByb3BfdHlwZXNfMSIsIlJvb3RGaW5kZXJfMSIsInN0cmluZ09yRnVuY3Rpb24iLCJkZWZhdWx0Iiwib25lT2ZUeXBlIiwiZnVuYyIsInN0cmluZyIsIm1ha2VWYWxpZEVsZW1lbnRUeXBlIiwiYWRhcHRlciIsInZhbGlkRWxlbWVudFR5cGVSZXF1aXJlZCIsInByb3BzIiwicHJvcE5hbWUiLCJhcmdzIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiaXNSZXF1aXJlZCIsInByb3BWYWx1ZSIsIlR5cGVFcnJvciIsInZhbGlkRWxlbWVudFR5cGUiLCJjcmVhdGVNb3VudFdyYXBwZXIiLCJub2RlIiwib3B0aW9ucyIsIndyYXBwaW5nQ29tcG9uZW50IiwiV3JhcHBpbmdDb21wb25lbnQiLCJXcmFwcGVyQ29tcG9uZW50IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJ3cmFwcGluZ0NvbXBvbmVudFByb3BzIiwiY29udGV4dCIsInN0YXRlIiwibW91bnQiLCJzZXRDaGlsZFByb3BzIiwibmV3UHJvcHMiLCJuZXdDb250ZXh0IiwiY2FsbGJhY2siLCJ1bmRlZmluZWQiLCJvbGRQcm9wcyIsIm9sZENvbnRleHQiLCJzZXRTdGF0ZSIsInNldFdyYXBwaW5nQ29tcG9uZW50UHJvcHMiLCJyZW5kZXIiLCJyZWZQcm9wIiwiY29tcG9uZW50IiwiY3JlYXRlRWxlbWVudCIsInJlZiIsImNvbXBvbmVudERpZE1vdW50Iiwib25SZW5kZXJDYiIsInByb3BUeXBlcyIsIm9iamVjdCIsInNoYXBlIiwiY3VycmVudCIsImFueSIsImRlZmF1bHRQcm9wcyIsInR5cGUiLCJjb250ZXh0VHlwZXMiLCJjaGlsZENvbnRleHRUeXBlcyIsInByb3RvdHlwZSIsImdldENoaWxkQ29udGV4dCJdLCJzb3VyY2VzIjpbImNyZWF0ZU1vdW50V3JhcHBlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIEB0cy1ub2NoZWNrXG5jb25zdCByZWFjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBwcm9wX3R5cGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xuY29uc3QgUm9vdEZpbmRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Jvb3RGaW5kZXJcIikpO1xuY29uc3Qgc3RyaW5nT3JGdW5jdGlvbiA9IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9uZU9mVHlwZShbcHJvcF90eXBlc18xLmRlZmF1bHQuZnVuYywgcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nXSk7XG5jb25zdCBtYWtlVmFsaWRFbGVtZW50VHlwZSA9IChhZGFwdGVyKSA9PiB7XG4gICAgaWYgKCFhZGFwdGVyKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdPckZ1bmN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZEVsZW1lbnRUeXBlUmVxdWlyZWQocHJvcHMsIHByb3BOYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmICghYWRhcHRlci5pc1ZhbGlkRWxlbWVudFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdPckZ1bmN0aW9uLmlzUmVxdWlyZWQocHJvcHMsIHByb3BOYW1lLCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICAgIGlmIChhZGFwdGVyLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgJHtwcm9wTmFtZX0gbXVzdCBiZSBhIHZhbGlkIGVsZW1lbnQgdHlwZSFgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRFbGVtZW50VHlwZShwcm9wcywgcHJvcE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICBpZiAocHJvcFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZEVsZW1lbnRUeXBlUmVxdWlyZWQocHJvcHMsIHByb3BOYW1lLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgdmFsaWRFbGVtZW50VHlwZS5pc1JlcXVpcmVkID0gdmFsaWRFbGVtZW50VHlwZVJlcXVpcmVkO1xuICAgIHJldHVybiB2YWxpZEVsZW1lbnRUeXBlO1xufTtcbi8qKlxuICogVGhpcyBpcyBhIHV0aWxpdHkgY29tcG9uZW50IHRvIHdyYXAgYXJvdW5kIHRoZSBub2RlcyB3ZSBhcmVcbiAqIHBhc3NpbmcgaW4gdG8gYG1vdW50KClgLiBUaGVvcmV0aWNhbGx5LCB5b3UgY291bGQgZG8gZXZlcnl0aGluZ1xuICogd2UgYXJlIGRvaW5nIHdpdGhvdXQgdGhpcywgYnV0IHRoaXMgbWFrZXMgaXQgZWFzaWVyIHNpbmNlXG4gKiBgcmVuZGVySW50b0RvY3VtZW50KClgIGRvZXNuJ3QgcmVhbGx5IHBhc3MgYmFjayBhIHJlZmVyZW5jZSB0b1xuICogdGhlIERPTSBub2RlIGl0IHJlbmRlcmVkIHRvLCBzbyB3ZSBjYW4ndCByZWFsbHkgXCJyZS1yZW5kZXJcIiB0b1xuICogcGFzcyBuZXcgcHJvcHMgaW4uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vdW50V3JhcHBlcihub2RlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFkYXB0ZXIsIHdyYXBwaW5nQ29tcG9uZW50OiBXcmFwcGluZ0NvbXBvbmVudCB9ID0gb3B0aW9ucztcbiAgICBjbGFzcyBXcmFwcGVyQ29tcG9uZW50IGV4dGVuZHMgcmVhY3RfMS5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wcywgd3JhcHBpbmdDb21wb25lbnRQcm9wcywgY29udGV4dCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgbW91bnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgd3JhcHBpbmdDb21wb25lbnRQcm9wcyxcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBzZXRDaGlsZFByb3BzKG5ld1Byb3BzLCBuZXdDb250ZXh0LCBjYWxsYmFjayA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgeyBwcm9wczogb2xkUHJvcHMsIGNvbnRleHQ6IG9sZENvbnRleHQgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHsgLi4ub2xkUHJvcHMsIC4uLm5ld1Byb3BzIH07XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0geyAuLi5vbGRDb250ZXh0LCAuLi5uZXdDb250ZXh0IH07XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgcHJvcHMsIGNvbnRleHQgfSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHNldFdyYXBwaW5nQ29tcG9uZW50UHJvcHMocHJvcHMsIGNhbGxiYWNrID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgd3JhcHBpbmdDb21wb25lbnRQcm9wczogcHJvcHMgfSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgQ29tcG9uZW50LCByZWZQcm9wIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgeyBtb3VudCwgcHJvcHMsIHdyYXBwaW5nQ29tcG9uZW50UHJvcHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBpZiAoIW1vdW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB7IHJlZjogcmVmUHJvcCwgLi4ucHJvcHMgfSk7XG4gICAgICAgICAgICBpZiAoV3JhcHBpbmdDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFdyYXBwaW5nQ29tcG9uZW50LCB7IC4uLndyYXBwaW5nQ29tcG9uZW50UHJvcHMgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVhY3RfMS5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUm9vdEZpbmRlcl8xLmRlZmF1bHQsIG51bGwsIGNvbXBvbmVudCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9uUmVuZGVyQ2IgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBvblJlbmRlckNiICYmIG9uUmVuZGVyQ2IodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgV3JhcHBlckNvbXBvbmVudC5wcm9wVHlwZXMgPSB7XG4gICAgICAgIENvbXBvbmVudDogbWFrZVZhbGlkRWxlbWVudFR5cGUoYWRhcHRlcikuaXNSZXF1aXJlZCxcbiAgICAgICAgY29udGV4dDogcHJvcF90eXBlc18xLmRlZmF1bHQub2JqZWN0LFxuICAgICAgICBwcm9wczogcHJvcF90eXBlc18xLmRlZmF1bHQub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgICAgIHJlZlByb3A6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9uZU9mVHlwZShbXG4gICAgICAgICAgICBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zdHJpbmcsXG4gICAgICAgICAgICBwcm9wX3R5cGVzXzEuZGVmYXVsdC5mdW5jLFxuICAgICAgICAgICAgcHJvcF90eXBlc18xLmRlZmF1bHQuc2hhcGUoe1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmFueSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdKSxcbiAgICAgICAgd3JhcHBpbmdDb21wb25lbnRQcm9wczogcHJvcF90eXBlc18xLmRlZmF1bHQub2JqZWN0LFxuICAgIH07XG4gICAgV3JhcHBlckNvbXBvbmVudC5kZWZhdWx0UHJvcHMgPSB7XG4gICAgICAgIHJlZlByb3A6IG51bGwsXG4gICAgICAgIGNvbnRleHQ6IG51bGwsXG4gICAgICAgIHdyYXBwaW5nQ29tcG9uZW50UHJvcHM6IG51bGwsXG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5jb250ZXh0ICYmIChub2RlLnR5cGUuY29udGV4dFR5cGVzIHx8IG9wdGlvbnMuY2hpbGRDb250ZXh0VHlwZXMpKSB7XG4gICAgICAgIC8vIEZvciBmdWxsIHJlbmRlcmluZywgd2UgYXJlIHVzaW5nIHRoaXMgd3JhcHBlciBjb21wb25lbnQgdG8gcHJvdmlkZSBjb250ZXh0IGlmIGl0IGlzXG4gICAgICAgIC8vIHNwZWNpZmllZCBpbiBib3RoIHRoZSBvcHRpb25zIEFORCB0aGUgY2hpbGQgY29tcG9uZW50IGRlZmluZXMgYGNvbnRleHRUeXBlc2Agc3RhdGljYWxseVxuICAgICAgICAvLyBPUiB0aGUgbWVyZ2VkIGNvbnRleHQgdHlwZXMgZm9yIGFsbCBjaGlsZHJlbiAodGhlIG5vZGUgY29tcG9uZW50IG9yIGRlZXBlciBjaGlsZHJlbikgYXJlXG4gICAgICAgIC8vIHNwZWNpZmllZCBpbiBvcHRpb25zIHBhcmFtZXRlciB1bmRlciBjaGlsZENvbnRleHRUeXBlcy5cbiAgICAgICAgLy8gSW4gdGhhdCBjYXNlLCB3ZSBkZWZpbmUgYm90aCBhIGBnZXRDaGlsZENvbnRleHQoKWAgZnVuY3Rpb24gYW5kIGEgYGNoaWxkQ29udGV4dFR5cGVzYCBwcm9wLlxuICAgICAgICBjb25zdCBjaGlsZENvbnRleHRUeXBlcyA9IHtcbiAgICAgICAgICAgIC4uLm5vZGUudHlwZS5jb250ZXh0VHlwZXMsXG4gICAgICAgICAgICAuLi5vcHRpb25zLmNoaWxkQ29udGV4dFR5cGVzLFxuICAgICAgICB9O1xuICAgICAgICBXcmFwcGVyQ29tcG9uZW50LnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jb250ZXh0O1xuICAgICAgICB9O1xuICAgICAgICBXcmFwcGVyQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID0gY2hpbGRDb250ZXh0VHlwZXM7XG4gICAgfVxuICAgIHJldHVybiBXcmFwcGVyQ29tcG9uZW50O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlTW91bnRXcmFwcGVyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQSxZQUFZOztBQUNaLElBQUlBLGVBQWUsR0FBSSxVQUFRLFNBQUtBLGVBQWUsSUFBSyxVQUFVQyxHQUFHLEVBQUU7RUFDbkUsT0FBUUEsR0FBRyxJQUFJQSxHQUFHLENBQUNDLFVBQVUsR0FBSUQsR0FBRyxHQUFHO0lBQUUsU0FBUyxFQUFFQTtFQUFJLENBQUM7QUFDN0QsQ0FBQztBQUNERSxNQUFNLENBQUNDLGNBQWMsQ0FBQ0MsT0FBTyxFQUFFLFlBQVksRUFBRTtFQUFFQyxL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