7972fabbf906444536ea44949bfbd46f
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDragPreviewOffset = getDragPreviewOffset;
exports.getEventClientOffset = getEventClientOffset;
exports.getNodeClientOffset = getNodeClientOffset;
var _BrowserDetector = require("./BrowserDetector.js");
var _MonotonicInterpolant = require("./MonotonicInterpolant.js");
const ELEMENT_NODE = 1;
function getNodeClientOffset(node) {
  const el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;
  if (!el) {
    return null;
  }
  const {
    top,
    left
  } = el.getBoundingClientRect();
  return {
    x: left,
    y: top
  };
}
function getEventClientOffset(e) {
  return {
    x: e.clientX,
    y: e.clientY
  };
}
function isImageNode(node) {
  var ref;
  return node.nodeName === 'IMG' && ((0, _BrowserDetector.isFirefox)() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node)));
}
function getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {
  let dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;
  let dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;
  // Work around @2x coordinate discrepancies in browsers
  if ((0, _BrowserDetector.isSafari)() && isImage) {
    dragPreviewHeight /= window.devicePixelRatio;
    dragPreviewWidth /= window.devicePixelRatio;
  }
  return {
    dragPreviewWidth,
    dragPreviewHeight
  };
}
function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {
  // The browsers will use the image intrinsic size under different conditions.
  // Firefox only cares if it's an image, but WebKit also wants it to be detached.
  const isImage = isImageNode(dragPreview);
  const dragPreviewNode = isImage ? sourceNode : dragPreview;
  const dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);
  const offsetFromDragPreview = {
    x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,
    y: clientOffset.y - dragPreviewNodeOffsetFromClient.y
  };
  const {
    offsetWidth: sourceWidth,
    offsetHeight: sourceHeight
  } = sourceNode;
  const {
    anchorX,
    anchorY
  } = anchorPoint;
  const {
    dragPreviewWidth,
    dragPreviewHeight
  } = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight);
  const calculateYOffset = () => {
    const interpolantY = new _MonotonicInterpolant.MonotonicInterpolant([0, 0.5, 1], [
    // Dock to the top
    offsetFromDragPreview.y,
    // Align at the center
    offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,
    // Dock to the bottom
    offsetFromDragPreview.y + dragPreviewHeight - sourceHeight]);
    let y = interpolantY.interpolate(anchorY);
    // Work around Safari 8 positioning bug
    if ((0, _BrowserDetector.isSafari)() && isImage) {
      // We'll have to wait for @3x to see if this is entirely correct
      y += (window.devicePixelRatio - 1) * dragPreviewHeight;
    }
    return y;
  };
  const calculateXOffset = () => {
    // Interpolate coordinates depending on anchor point
    // If you know a simpler way to do this, let me know
    const interpolantX = new _MonotonicInterpolant.MonotonicInterpolant([0, 0.5, 1], [
    // Dock to the left
    offsetFromDragPreview.x,
    // Align at the center
    offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,
    // Dock to the right
    offsetFromDragPreview.x + dragPreviewWidth - sourceWidth]);
    return interpolantX.interpolate(anchorX);
  };
  // Force offsets if specified in the options.
  const {
    offsetX,
    offsetY
  } = offsetPoint;
  const isManualOffsetX = offsetX === 0 || offsetX;
  const isManualOffsetY = offsetY === 0 || offsetY;
  return {
    x: isManualOffsetX ? offsetX : calculateXOffset(),
    y: isManualOffsetY ? offsetY : calculateYOffset()
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfQnJvd3NlckRldGVjdG9yIiwicmVxdWlyZSIsIl9Nb25vdG9uaWNJbnRlcnBvbGFudCIsIkVMRU1FTlRfTk9ERSIsImdldE5vZGVDbGllbnRPZmZzZXQiLCJub2RlIiwiZWwiLCJub2RlVHlwZSIsInBhcmVudEVsZW1lbnQiLCJ0b3AiLCJsZWZ0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieCIsInkiLCJnZXRFdmVudENsaWVudE9mZnNldCIsImUiLCJjbGllbnRYIiwiY2xpZW50WSIsImlzSW1hZ2VOb2RlIiwicmVmIiwibm9kZU5hbWUiLCJpc0ZpcmVmb3giLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImNvbnRhaW5zIiwiZ2V0RHJhZ1ByZXZpZXdTaXplIiwiaXNJbWFnZSIsImRyYWdQcmV2aWV3Iiwic291cmNlV2lkdGgiLCJzb3VyY2VIZWlnaHQiLCJkcmFnUHJldmlld1dpZHRoIiwid2lkdGgiLCJkcmFnUHJldmlld0hlaWdodCIsImhlaWdodCIsImlzU2FmYXJpIiwid2luZG93IiwiZGV2aWNlUGl4ZWxSYXRpbyIsImdldERyYWdQcmV2aWV3T2Zmc2V0Iiwic291cmNlTm9kZSIsImNsaWVudE9mZnNldCIsImFuY2hvclBvaW50Iiwib2Zmc2V0UG9pbnQiLCJkcmFnUHJldmlld05vZGUiLCJkcmFnUHJldmlld05vZGVPZmZzZXRGcm9tQ2xpZW50Iiwib2Zmc2V0RnJvbURyYWdQcmV2aWV3Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJhbmNob3JYIiwiYW5jaG9yWSIsImNhbGN1bGF0ZVlPZmZzZXQiLCJpbnRlcnBvbGFudFkiLCJNb25vdG9uaWNJbnRlcnBvbGFudCIsImludGVycG9sYXRlIiwiY2FsY3VsYXRlWE9mZnNldCIsImludGVycG9sYW50WCIsIm9mZnNldFgiLCJvZmZzZXRZIiwiaXNNYW51YWxPZmZzZXRYIiwiaXNNYW51YWxPZmZzZXRZIl0sInNvdXJjZXMiOlsiLi4vc3JjL09mZnNldFV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgWFlDb29yZCB9IGZyb20gJ2RuZC1jb3JlJ1xuXG5pbXBvcnQgeyBpc0ZpcmVmb3gsIGlzU2FmYXJpIH0gZnJvbSAnLi9Ccm93c2VyRGV0ZWN0b3IuanMnXG5pbXBvcnQgeyBNb25vdG9uaWNJbnRlcnBvbGFudCB9IGZyb20gJy4vTW9ub3RvbmljSW50ZXJwb2xhbnQuanMnXG5cbmNvbnN0IEVMRU1FTlRfTk9ERSA9IDFcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVDbGllbnRPZmZzZXQobm9kZTogTm9kZSk6IFhZQ29vcmQgfCBudWxsIHtcblx0Y29uc3QgZWwgPSBub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgPyBub2RlIDogbm9kZS5wYXJlbnRFbGVtZW50XG5cblx0aWYgKCFlbCkge1xuXHRcdHJldHVybiBudWxsXG5cdH1cblxuXHRjb25zdCB7IHRvcCwgbGVmdCB9ID0gKGVsIGFzIEhUTUxFbGVtZW50KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXHRyZXR1cm4geyB4OiBsZWZ0LCB5OiB0b3AgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXZlbnRDbGllbnRPZmZzZXQoZTogTW91c2VFdmVudCk6IFhZQ29vcmQge1xuXHRyZXR1cm4ge1xuXHRcdHg6IGUuY2xpZW50WCxcblx0XHR5OiBlLmNsaWVudFksXG5cdH1cbn1cblxuZnVuY3Rpb24gaXNJbWFnZU5vZGUobm9kZTogYW55KSB7XG5cdHJldHVybiAoXG5cdFx0bm9kZS5ub2RlTmFtZSA9PT0gJ0lNRycgJiZcblx0XHQoaXNGaXJlZm94KCkgfHwgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudD8uY29udGFpbnMobm9kZSkpXG5cdClcbn1cblxuZnVuY3Rpb24gZ2V0RHJhZ1ByZXZpZXdTaXplKFxuXHRpc0ltYWdlOiBib29sZWFuLFxuXHRkcmFnUHJldmlldzogYW55LFxuXHRzb3VyY2VXaWR0aDogbnVtYmVyLFxuXHRzb3VyY2VIZWlnaHQ6IG51bWJlcixcbikge1xuXHRsZXQgZHJhZ1ByZXZpZXdXaWR0aCA9IGlzSW1hZ2UgPyBkcmFnUHJldmlldy53aWR0aCA6IHNvdXJjZVdpZHRoXG5cdGxldCBkcmFnUHJldmlld0hlaWdodCA9IGlzSW1hZ2UgPyBkcmFnUHJldmlldy5oZWlnaHQgOiBzb3VyY2VIZWlnaHRcblxuXHQvLyBXb3JrIGFyb3VuZCBAMnggY29vcmRpbmF0ZSBkaXNjcmVwYW5jaWVzIGluIGJyb3dzZXJzXG5cdGlmIChpc1NhZmFyaSgpICYmIGlzSW1hZ2UpIHtcblx0XHRkcmFnUHJldmlld0hlaWdodCAvPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb1xuXHRcdGRyYWdQcmV2aWV3V2lkdGggLz0gd2luZG93LmRldmljZVBpeGVsUmF0aW9cblx0fVxuXHRyZXR1cm4geyBkcmFnUHJldmlld1dpZHRoLCBkcmFnUHJldmlld0hlaWdodCB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREcmFnUHJldmlld09mZnNldChcblx0c291cmNlTm9kZTogSFRNTEVsZW1lbnQsXG5cdGRyYWdQcmV2aWV3OiBIVE1MRWxlbWVudCxcblx0Y2xpZW50T2Zmc2V0OiBYWUNvb3JkLFxuXHRhbmNob3JQb2ludDogeyBhbmNob3JYOiBudW1iZXI7IGFuY2hvclk6IG51bWJlciB9LFxuXHRvZmZzZXRQb2ludDogeyBvZmZzZXRYOiBudW1iZXI7IG9mZnNldFk6IG51bWJlciB9LFxuKTogWFlDb29yZCB7XG5cdC8vIFRoZSBicm93c2VycyB3aWxsIHVzZSB0aGUgaW1hZ2UgaW50cmluc2ljIHNpemUgdW5kZXIgZGlmZmVyZW50IGNvbmRpdGlvbnMuXG5cdC8vIEZpcmVmb3ggb25seSBjYXJlcyBpZiBpdCdzIGFuIGltYWdlLCBidXQgV2ViS2l0IGFsc28gd2FudHMgaXQgdG8gYmUgZGV0YWNoZWQuXG5cdGNvbnN0IGlzSW1hZ2UgPSBpc0ltYWdlTm9kZShkcmFnUHJldmlldylcblx0Y29uc3QgZHJhZ1ByZXZpZXdOb2RlID0gaXNJbWFnZSA/IHNvdXJjZU5vZGUgOiBkcmFnUHJldmlld1xuXHRjb25zdCBkcmFnUHJldmlld05vZGVPZmZzZXRGcm9tQ2xpZW50ID0gZ2V0Tm9kZUNsaWVudE9mZnNldChcblx0XHRkcmFnUHJldmlld05vZGUsXG5cdCkgYXMgWFlDb29yZFxuXHRjb25zdCBvZmZzZXRGcm9tRHJhZ1ByZXZpZXcgPSB7XG5cdFx0eDogY2xpZW50T2Zmc2V0LnggLSBkcmFnUHJldmlld05vZGVPZmZzZXRGcm9tQ2xpZW50LngsXG5cdFx0eTogY2xpZW50T2Zmc2V0LnkgLSBkcmFnUHJldmlld05vZGVPZmZzZXRGcm9tQ2xpZW50LnksXG5cdH1cblx0Y29uc3QgeyBvZmZzZXRXaWR0aDogc291cmNlV2lkdGgsIG9mZnNldEhlaWdodDogc291cmNlSGVpZ2h0IH0gPSBzb3VyY2VOb2RlXG5cdGNvbnN0IHsgYW5jaG9yWCwgYW5jaG9yWSB9ID0gYW5jaG9yUG9pbnRcblx0Y29uc3QgeyBkcmFnUHJldmlld1dpZHRoLCBkcmFnUHJldmlld0hlaWdodCB9ID0gZ2V0RHJhZ1ByZXZpZXdTaXplKFxuXHRcdGlzSW1hZ2UsXG5cdFx0ZHJhZ1ByZXZpZXcsXG5cdFx0c291cmNlV2lkdGgsXG5cdFx0c291cmNlSGVpZ2h0LFxuXHQpXG5cblx0Y29uc3QgY2FsY3VsYXRlWU9mZnNldCA9ICgpID0+IHtcblx0XHRjb25zdCBpbnRlcnBvbGFudFkgPSBuZXcgTW9ub3RvbmljSW50ZXJwb2xhbnQoXG5cdFx0XHRbMCwgMC41LCAxXSxcblx0XHRcdFtcblx0XHRcdFx0Ly8gRG9jayB0byB0aGUgdG9wXG5cdFx0XHRcdG9mZnNldEZyb21EcmFnUHJldmlldy55LFxuXHRcdFx0XHQvLyBBbGlnbiBhdCB0aGUgY2VudGVyXG5cdFx0XHRcdChvZmZzZXRGcm9tRHJhZ1ByZXZpZXcueSAvIHNvdXJjZUhlaWdodCkgKiBkcmFnUHJldmlld0hlaWdodCxcblx0XHRcdFx0Ly8gRG9jayB0byB0aGUgYm90dG9tXG5cdFx0XHRcdG9mZnNldEZyb21EcmFnUHJldmlldy55ICsgZHJhZ1ByZXZpZXdIZWlnaHQgLSBzb3VyY2VIZWlnaHQsXG5cdFx0XHRdLFxuXHRcdClcblx0XHRsZXQgeSA9IGludGVycG9sYW50WS5pbnRlcnBvbGF0ZShhbmNob3JZKVxuXHRcdC8vIFdvcmsgYXJvdW5kIFNhZmFyaSA4IHBvc2l0aW9uaW5nIGJ1Z1xuXHRcdGlmIChpc1NhZmFyaSgpICYmIGlzSW1hZ2UpIHtcblx0XHRcdC8vIFdlJ2xsIGhhdmUgdG8gd2FpdCBmb3IgQDN4IHRvIHNlZSBpZiB0aGlzIGlzIGVudGlyZWx5IGNvcnJlY3Rcblx0XHRcdHkgKz0gKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIC0gMSkgKiBkcmFnUHJldmlld0hlaWdodFxuXHRcdH1cblx0XHRyZXR1cm4geVxuXHR9XG5cblx0Y29uc3QgY2FsY3VsYXRlWE9mZnNldCA9ICgpID0+IHtcblx0XHQvLyBJbnRlcnBvbGF0ZSBjb29yZGluYXRlcyBkZXBlbmRpbmcgb24gYW5jaG9yIHBvaW50XG5cdFx0Ly8gSWYgeW91IGtub3cgYSBzaW1wbGVyIHdheSB0byBkbyB0aGlzLCBsZXQgbWUga25vd1xuXHRcdGNvbnN0IGludGVycG9sYW50WCA9IG5ldyBNb25vdG9uaWNJbnRlcnBvbGFudChcblx0XHRcdFswLCAwLjUsIDFdLFxuXHRcdFx0W1xuXHRcdFx0XHQvLyBEb2NrIHRvIHRoZSBsZWZ0XG5cdFx0XHRcdG9mZnNldEZyb21EcmFnUHJldmlldy54LFxuXHRcdFx0XHQvLyBBbGlnbiBhdCB0aGUgY2VudGVyXG5cdFx0XHRcdChvZmZzZXRGcm9tRHJhZ1ByZXZpZXcueCAvIHNvdXJjZVdpZHRoKSAqIGRyYWdQcmV2aWV3V2lkdGgsXG5cdFx0XHRcdC8vIERvY2sgdG8gdGhlIHJpZ2h0XG5cdFx0XHRcdG9mZnNldEZyb21EcmFnUHJldmlldy54ICsgZHJhZ1ByZXZpZXdXaWR0aCAtIHNvdXJjZVdpZHRoLFxuXHRcdFx0XSxcblx0XHQpXG5cdFx0cmV0dXJuIGludGVycG9sYW50WC5pbnRlcnBvbGF0ZShhbmNob3JYKVxuXHR9XG5cblx0Ly8gRm9yY2Ugb2Zmc2V0cyBpZiBzcGVjaWZpZWQgaW4gdGhlIG9wdGlvbnMuXG5cdGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gb2Zmc2V0UG9pbnRcblx0Y29uc3QgaXNNYW51YWxPZmZzZXRYID0gb2Zmc2V0WCA9PT0gMCB8fCBvZmZzZXRYXG5cdGNvbnN0IGlzTWFudWFsT2Zmc2V0WSA9IG9mZnNldFkgPT09IDAgfHwgb2Zmc2V0WVxuXHRyZXR1cm4ge1xuXHRcdHg6IGlzTWFudWFsT2Zmc2V0WCA/IG9mZnNldFggOiBjYWxjdWxhdGVYT2Zmc2V0KCksXG5cdFx0eTogaXNNYW51YWxPZmZzZXRZID8gb2Zmc2V0WSA6IGNhbGN1bGF0ZVlPZmZzZXQoKSxcblx0fVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUVBLElBQUFBLGdCQUFBLEdBQUFDLE9BQUE7QUFDQSxJQUFBQyxxQkFBQSxHQUFBRCxPQUFBO0FBRUEsTUFBTUUsWUFBWSxHQUFHLENBQUM7QUFFZixTQUFTQyxtQkFBbUJBLENBQUNDLElBQVUsRUFBa0I7RUFDL0QsTUFBTUMsRUFBRSxHQUFHRCxJQUFJLENBQUNFLFFBQVEsS0FBS0osWUFBWSxHQUFHRSxJQUFJLEdBQUdBLElBQUksQ0FBQ0csYUFBYTtFQUVyRSxJQUFJLENBQUNGLEVBQUUsRUFBRTtJQUNSLE9BQU8sSUFBSTs7RUFHWixNQUFNO0lBQUVHLEdBQUc7SUFBRUM7RUFBSSxDQUFFLEdBQUdKLEVBQUcsQ0FBaUJLLHFCQUFxQixFQUFFO0VBQ2pFLE9BQU87SUFBRUMsQ0FBQyxFQUFFRixJQUFJO0lBQUVHLENBQUMsRUFBRUo7R0FBSzs7QUFHcEIsU0FBU0ssb0JBQW9CQSxDQUFDQyxDQUFhLEVBQVc7RUFDNUQsT0FBTztJQUNOSCxDQUFDLEVBQUVHLENBQUMsQ0FBQ0MsT0FBTztJQUNaSCxDQUFDLEVBQUVFLENBQUMsQ0FBQ0U7R0FDTDs7QUFHRixTQUFTQyxXQUFXQSxDQUFDYixJQUFTLEVBQUU7TUFHYmMsR0FBd0I7RUFGMUMsT0FDQ2QsSUFBSSxDQUFDZSxRQUFRLEtBQUss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