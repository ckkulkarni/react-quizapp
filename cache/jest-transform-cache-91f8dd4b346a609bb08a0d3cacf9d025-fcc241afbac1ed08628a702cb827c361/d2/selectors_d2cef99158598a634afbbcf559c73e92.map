{"version":3,"names":["buildPredicate","reduceTreeBySelector","reduceTreesBySelector","_rstSelectorParser","require","_object","_arrayPrototype","_objectIs","_has","_byConstructor","_RSTTraversal","_Utils","_getAdapter","parser","createParser","CHILD","ADJACENT_SIBLING","GENERAL_SIBLING","DESCENDANT","SELECTOR","TYPE_SELECTOR","CLASS_SELECTOR","ID_SELECTOR","UNIVERSAL_SELECTOR","ATTRIBUTE_PRESENCE","ATTRIBUTE_VALUE","PSEUDO_CLASS","PSEUDO_ELEMENT","EXACT_ATTRIBUTE_OPERATOR","WHITELIST_ATTRIBUTE_OPERATOR","HYPHENATED_ATTRIBUTE_OPERATOR","PREFIX_ATTRIBUTE_OPERATOR","SUFFIX_ATTRIBUTE_OPERATOR","SUBSTRING_ATTRIBUTE_OPERATOR","unique","arr","concat","_toConsumableArray","Set","uniqueReduce","fn","nodes","reduce","safelyGenerateTokens","selector","parse","err","Error","String","matchAttributeSelector","node","token","operator","value","name","nodeProps","propsOfNode","descriptor","Object","getOwnPropertyDescriptor","get","nodePropValue","type","_has2","_objectIs2","split","indexOf","startsWith","slice","length","matchPseudoSelector","root","parameters","every","treeFilter","n","_findParentNode","findParentNode","rendered","_rendered","_slicedToArray","firstChild","_findParentNode2","_rendered2","document","adapter","_getAdapter2","activeElement","nodeToHostNode","TypeError","nodeMatchesToken","hasClassName","nodeHasType","nodeHasId","buildPredicateFromToken","body","bodyToken","isComplexSelector","tokens","some","isElementType","isValidElementType","matchesElementType","_typeof","Array","isArray","keys","hasUndefinedValues","_object2","nodeMatchesObjectProps","matchAdjacentSiblings","predicate","matches","parent","parentChildren","childrenOfNode","nodeIndex","adjacentSibling","push","matchGeneralSibling","youngerSiblings","filter","matchDirectChild","matchDescendant","_arrayPrototype2","map","elements","_byConstructor2","x","tag","results","index","_predicate","roots"],"sources":["../src/selectors.js"],"sourcesContent":["import { createParser } from 'rst-selector-parser';\nimport values from 'object.values';\nimport flat from 'array.prototype.flat';\nimport is from 'object-is';\nimport has from 'has';\nimport elementsByConstructor from 'html-element-map/byConstructor';\nimport {\n  treeFilter,\n  nodeHasId,\n  findParentNode,\n  nodeMatchesObjectProps,\n  childrenOfNode,\n  hasClassName,\n} from './RSTTraversal';\nimport { nodeHasType, propsOfNode } from './Utils';\nimport getAdapter from './getAdapter';\n// our CSS selector parser instance\nconst parser = createParser();\n\n// Combinators that allow you to chance selectors\nconst CHILD = 'childCombinator';\nconst ADJACENT_SIBLING = 'adjacentSiblingCombinator';\nconst GENERAL_SIBLING = 'generalSiblingCombinator';\nconst DESCENDANT = 'descendantCombinator';\n\n// Selectors for targeting elements\nconst SELECTOR = 'selector';\nconst TYPE_SELECTOR = 'typeSelector';\nconst CLASS_SELECTOR = 'classSelector';\nconst ID_SELECTOR = 'idSelector';\nconst UNIVERSAL_SELECTOR = 'universalSelector';\nconst ATTRIBUTE_PRESENCE = 'attributePresenceSelector';\nconst ATTRIBUTE_VALUE = 'attributeValueSelector';\n// @TODO we dont support these, throw if they are used\nconst PSEUDO_CLASS = 'pseudoClassSelector';\nconst PSEUDO_ELEMENT = 'pseudoElementSelector';\n\nconst EXACT_ATTRIBUTE_OPERATOR = '=';\nconst WHITELIST_ATTRIBUTE_OPERATOR = '~=';\nconst HYPHENATED_ATTRIBUTE_OPERATOR = '|=';\nconst PREFIX_ATTRIBUTE_OPERATOR = '^=';\nconst SUFFIX_ATTRIBUTE_OPERATOR = '$=';\nconst SUBSTRING_ATTRIBUTE_OPERATOR = '*=';\n\nfunction unique(arr) {\n  return [...new Set(arr)];\n}\n\n/**\n * Calls reduce on a array of nodes with the passed\n * function, returning only unique results.\n * @param {Function} fn\n * @param {Array<Node>} nodes\n */\nfunction uniqueReduce(fn, nodes) {\n  return unique(nodes.reduce(fn, []));\n}\n\n/**\n * Takes a CSS selector and returns a set of tokens parsed\n * by scalpel.\n * @param {String} selector\n */\nfunction safelyGenerateTokens(selector) {\n  try {\n    return parser.parse(selector);\n  } catch (err) {\n    throw new Error(`Failed to parse selector: ${selector}`);\n  }\n}\n\nfunction matchAttributeSelector(node, token) {\n  const { operator, value, name } = token;\n  const nodeProps = propsOfNode(node);\n  const descriptor = Object.getOwnPropertyDescriptor(nodeProps, name);\n  if (descriptor && descriptor.get) {\n    return false;\n  }\n  const nodePropValue = nodeProps[name];\n  if (typeof nodePropValue === 'undefined') {\n    return false;\n  }\n  if (token.type === ATTRIBUTE_PRESENCE) {\n    return has(nodeProps, token.name);\n  }\n  // Only the exact value operator (\"=\") can match non-strings\n  if (typeof nodePropValue !== 'string' || typeof value !== 'string') {\n    if (operator !== EXACT_ATTRIBUTE_OPERATOR) {\n      return false;\n    }\n  }\n  switch (operator) {\n    /**\n     * Represents an element with the att attribute whose value is exactly \"val\".\n     * @example\n     * [attr=\"val\"] matches attr=\"val\"\n     */\n    case EXACT_ATTRIBUTE_OPERATOR:\n      return is(nodePropValue, value);\n    /**\n     * Represents an element with the att attribute whose value is a whitespace-separated\n     * list of words, one of which is exactly\n     * @example\n     *  [rel~=\"copyright\"] matches rel=\"copyright other\"\n     */\n    case WHITELIST_ATTRIBUTE_OPERATOR:\n      return nodePropValue.split(' ').indexOf(value) !== -1;\n    /**\n     * Represents an element with the att attribute, its value either being exactly the\n     * value or beginning with the value immediately followed by \"-\"\n     * @example\n     * [hreflang|=\"en\"] matches hreflang=\"en-US\"\n     */\n    case HYPHENATED_ATTRIBUTE_OPERATOR:\n      return nodePropValue === value || nodePropValue.startsWith(`${value}-`);\n    /**\n     * Represents an element with the att attribute whose value begins with the prefix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type^=\"image\"] matches type=\"imageobject\"\n     */\n    case PREFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(0, value.length) === value;\n    /**\n     * Represents an element with the att attribute whose value ends with the suffix value.\n     * If the value is the empty string then the selector does not represent anything.\n     * @example\n     * [type$=\"image\"] matches type=\"imageobject\"\n     */\n    case SUFFIX_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.slice(-value.length) === value;\n    /**\n     * Represents an element with the att attribute whose value contains at least one\n     * instance of the value. If value is the empty string then the\n     * selector does not represent anything.\n     * @example\n     * [title*=\"hello\"] matches title=\"well hello there\"\n     */\n    case SUBSTRING_ATTRIBUTE_OPERATOR:\n      return value === '' ? false : nodePropValue.indexOf(value) !== -1;\n    default:\n      throw new Error(`Enzyme::Selector: Unknown attribute selector operator \"${operator}\"`);\n  }\n}\n\n\nfunction matchPseudoSelector(node, token, root) {\n  const { name, parameters } = token;\n  if (name === 'not') {\n    // eslint-disable-next-line no-use-before-define\n    return parameters.every((selector) => reduceTreeBySelector(selector, node).length === 0);\n  }\n  if (name === 'empty') {\n    return treeFilter(node, (n) => n !== node).length === 0;\n  }\n  if (name === 'first-child') {\n    const { rendered } = findParentNode(root, node);\n    const [firstChild] = rendered;\n    return firstChild === node;\n  }\n  if (name === 'last-child') {\n    const { rendered } = findParentNode(root, node);\n    return rendered[rendered.length - 1] === node;\n  }\n  if (name === 'focus') {\n    if (typeof document === 'undefined') {\n      throw new Error('Enzyme::Selector does not support the \":focus\" pseudo-element without a global `document`.');\n    }\n    const adapter = getAdapter();\n    /* eslint-env browser */\n    return document.activeElement && adapter.nodeToHostNode(node) === document.activeElement;\n  }\n\n  throw new TypeError(`Enzyme::Selector does not support the \"${token.name}\" pseudo-element or pseudo-class selectors.`);\n}\n\n/**\n * Takes a node and a token and determines if the node\n * matches the predicate defined by the token.\n * @param {Node} node\n * @param {Token} token\n */\nfunction nodeMatchesToken(node, token, root) {\n  if (node === null || typeof node === 'string') {\n    return false;\n  }\n  switch (token.type) {\n    /**\n     * Match every node\n     * @example '*' matches every node\n     */\n    case UNIVERSAL_SELECTOR:\n      return true;\n    /**\n     * Match against the className prop\n     * @example '.active' matches <div className='active' />\n     */\n    case CLASS_SELECTOR:\n      return hasClassName(node, token.name);\n    /**\n     * Simple type matching\n     * @example 'div' matches <div />\n     */\n    case TYPE_SELECTOR:\n      return nodeHasType(node, token.name);\n    /**\n     * Match against the `id` prop\n     * @example '#nav' matches <ul id=\"nav\" />\n     */\n    case ID_SELECTOR:\n      return nodeHasId(node, token.name);\n    /**\n     * Matches if an attribute is present, regardless\n     * of its value\n     * @example '[disabled]' matches <a disabled />\n     */\n    case ATTRIBUTE_PRESENCE:\n      return matchAttributeSelector(node, token);\n    /**\n     * Matches if an attribute is present with the\n     * provided value\n     * @example '[data-foo=foo]' matches <div data-foo=\"foo\" />\n     */\n    case ATTRIBUTE_VALUE:\n      return matchAttributeSelector(node, token);\n    case PSEUDO_ELEMENT:\n    case PSEUDO_CLASS:\n      return matchPseudoSelector(node, token, root);\n    default:\n      throw new Error(`Unknown token type: ${token.type}`);\n  }\n}\n\n/**\n * Returns a predicate function that checks if a\n * node matches every token in the body of a selector\n * token.\n * @param {Token} token\n */\nfunction buildPredicateFromToken(token, root) {\n  return (node) => token.body.every((bodyToken) => nodeMatchesToken(node, bodyToken, root));\n}\n\n/**\n * Returns whether a parsed selector is a complex selector, which\n * is defined as a selector that contains combinators.\n * @param {Array<Token>} tokens\n */\nfunction isComplexSelector(tokens) {\n  return tokens.some((token) => token.type !== SELECTOR);\n}\n\n\n/**\n * Takes a component constructor, object, or string representing\n * a simple selector and returns a predicate function that can\n * be applied to a single node.\n * @param {EnzymeSelector} selector\n */\nexport function buildPredicate(selector) {\n  // If the selector is a string, parse it as a simple CSS selector\n  if (typeof selector === 'string') {\n    const tokens = safelyGenerateTokens(selector);\n    if (isComplexSelector(tokens)) {\n      throw new TypeError('This method does not support complex CSS selectors');\n    }\n    // Simple selectors only have a single selector token\n    return buildPredicateFromToken(tokens[0]);\n  }\n\n  // If the selector is an element type, check if the node's type matches\n  const adapter = getAdapter();\n  const isElementType = adapter.isValidElementType\n    ? adapter.isValidElementType(selector)\n    : typeof selector === 'function';\n  if (isElementType) {\n    return (node) => adapter.matchesElementType(node, selector);\n  }\n  // If the selector is an non-empty object, treat the keys/values as props\n  if (typeof selector === 'object') {\n    if (!Array.isArray(selector) && selector !== null && Object.keys(selector).length > 0) {\n      const hasUndefinedValues = values(selector).some((value) => typeof value === 'undefined');\n      if (hasUndefinedValues) {\n        throw new TypeError('Enzyme::Props can’t have `undefined` values. Try using ‘findWhere()’ instead.');\n      }\n      return (node) => nodeMatchesObjectProps(node, selector);\n    }\n    throw new TypeError('Enzyme::Selector does not support an array, null, or empty object as a selector');\n  }\n\n  throw new TypeError('Enzyme::Selector expects a string, object, or valid element type (Component Constructor)');\n}\n\n/**\n * Matches only nodes which are adjacent siblings (direct next sibling)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\nfunction matchAdjacentSiblings(nodes, predicate, root) {\n  return nodes.reduce((matches, node) => {\n    const parent = findParentNode(root, node);\n    // If there's no parent, there's no siblings\n    if (!parent) {\n      return matches;\n    }\n    const parentChildren = childrenOfNode(parent);\n    const nodeIndex = parentChildren.indexOf(node);\n    const adjacentSibling = parentChildren[nodeIndex + 1];\n    // No sibling\n    if (!adjacentSibling) {\n      return matches;\n    }\n    if (predicate(adjacentSibling)) {\n      matches.push(adjacentSibling);\n    }\n    return matches;\n  }, []);\n}\n\n/**\n * Matches only nodes which are general siblings (any sibling *after*)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n * @param {Node} root\n */\nfunction matchGeneralSibling(nodes, predicate, root) {\n  return uniqueReduce((matches, node) => {\n    const parent = findParentNode(root, node);\n    if (!parent) {\n      return matches;\n    }\n    const parentChildren = childrenOfNode(parent);\n    const nodeIndex = parentChildren.indexOf(node);\n    const youngerSiblings = parentChildren.slice(nodeIndex + 1);\n    return matches.concat(youngerSiblings.filter(predicate));\n  }, nodes);\n}\n\n/**\n * Matches only nodes which are direct children (not grandchildren, etc.)\n * against a predicate, returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\nfunction matchDirectChild(nodes, predicate) {\n  return uniqueReduce(\n    (matches, node) => matches.concat(childrenOfNode(node).filter(predicate)),\n    nodes,\n  );\n}\n\n/**\n * Matches all descendant nodes against a predicate,\n * returning those that match.\n * @param {Array<Node>} nodes\n * @param {Function} predicate\n */\nfunction matchDescendant(nodes, predicate) {\n  return uniqueReduce(\n    (matches, node) => matches.concat(treeFilter(node, predicate)),\n    flat(nodes.map(childrenOfNode)),\n  );\n}\n\n/**\n * Takes an RST and reduces it to a set of nodes matching\n * the selector. The selector can be a simple selector, which\n * is handled by `buildPredicate`, or a complex CSS selector which\n * reduceTreeBySelector parses and reduces the tree based on the combinators.\n *\n * @param {EnzymeSelector} selector\n * @param {RSTNode} root\n */\nexport function reduceTreeBySelector(selector, root) {\n  if (typeof selector !== 'string') {\n    const elements = elementsByConstructor(selector);\n    if (elements.length > 0) {\n      return flat(elements.map((x) => reduceTreeBySelector(x.tag, root)));\n\n      // when https://github.com/aweary/rst-selector-parser/issues/15 is resolved\n      // const htmlTagNames = elements.map(x => x.tag).join(', ');\n      // return reduceTreeBySelector(htmlTagNames, root);\n    }\n  }\n\n  if (typeof selector === 'function' || typeof selector === 'object') {\n    return treeFilter(root, buildPredicate(selector));\n  }\n\n  let results = [];\n  if (typeof selector === 'string') {\n    const tokens = safelyGenerateTokens(selector);\n    let index = 0;\n    while (index < tokens.length) {\n      const token = tokens[index];\n      /**\n       * There are two types of tokens in a CSS selector:\n       *\n       * 1. Selector tokens. These target nodes directly, like\n       *    type or attribute selectors. These are easy to apply\n       *    because we can traverse the tree and return only\n       *    the nodes that match the predicate.\n       *\n       * 2. Combinator tokens. These tokens chain together\n       *    selector nodes. For example > for children, or +\n       *    for adjacent siblings. These are harder to match\n       *    as we have to track where in the tree we are\n       *    to determine if a selector node applies or not.\n       */\n      if (token.type === SELECTOR) {\n        const predicate = buildPredicateFromToken(token, root);\n        results = results.concat(treeFilter(root, predicate));\n      } else {\n        // We can assume there always all previously matched tokens since selectors\n        // cannot start with combinators.\n        const { type } = token;\n        // We assume the next token is a selector, so move the index\n        // forward and build the predicate.\n        index += 1;\n        const predicate = buildPredicateFromToken(tokens[index], root);\n        // We match against only the nodes which have already been matched,\n        // since a combinator is meant to refine a previous selector.\n        switch (type) {\n          // The + combinator\n          case ADJACENT_SIBLING:\n            results = matchAdjacentSiblings(results, predicate, root);\n            break;\n          // The ~ combinator\n          case GENERAL_SIBLING:\n            results = matchGeneralSibling(results, predicate, root);\n            break;\n          // The > combinator\n          case CHILD:\n            results = matchDirectChild(results, predicate);\n            break;\n          // The ' ' (whitespace) combinator\n          case DESCENDANT: {\n            results = matchDescendant(results, predicate);\n            break;\n          }\n          default:\n            throw new Error(`Unknown combinator selector: ${type}`);\n        }\n      }\n      index += 1;\n    }\n  } else {\n    throw new TypeError('Enzyme::Selector expects a string, object, or Component Constructor');\n  }\n  return results;\n}\n\nexport function reduceTreesBySelector(selector, roots) {\n  const results = roots.map((n) => reduceTreeBySelector(selector, n));\n  return unique(flat(results, 1));\n}\n"],"mappings":"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"}