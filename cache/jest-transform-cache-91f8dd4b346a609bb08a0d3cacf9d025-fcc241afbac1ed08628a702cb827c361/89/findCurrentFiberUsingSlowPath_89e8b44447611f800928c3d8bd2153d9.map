{"version":3,"names":["Object","defineProperty","exports","value","HostRoot","HostPortal","HostComponent","HostText","Placement","Hydrating","NoFlags","getNearestMountedFiber","fiber","node","nearestMounted","alternate","nextNode","flags","return","tag","findCurrentFiberUsingSlowPath","Error","a","b","parentA","parentB","nextParent","child","sibling","didFindChild","stateNode","current","findCurrentHostFiberImpl","match","findCurrentHostFiberWithNoPortalsImpl","default"],"sources":["findCurrentFiberUsingSlowPath.js"],"sourcesContent":["\"use strict\";\n// // Lifted from from https://github.com/facebook/react/blob/b76103d66fdb7396cbfcc66a032b31a0cd8ad342/packages/react-reconciler/src/ReactFiberTreeReflection.js\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nconst HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nconst HostComponent = 5;\nconst HostText = 6;\nconst Placement = 0b0000000000000000000000010;\nconst Hydrating = 0b0000000000001000000000000;\nconst NoFlags = 0b0000000000000000000000000;\nfunction getNearestMountedFiber(fiber) {\n    let node = fiber;\n    let nearestMounted = fiber;\n    if (!fiber.alternate) {\n        // If there is no alternate, this might be a new tree that isn't inserted\n        // yet. If it is, then it will have a pending insertion effect on it.\n        let nextNode = node;\n        do {\n            node = nextNode;\n            if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\n                // This is an insertion or in-progress hydration. The nearest possible\n                // mounted fiber is the parent but we need to continue to figure out\n                // if that one is still mounted.\n                nearestMounted = node.return;\n            }\n            nextNode = node.return;\n        } while (nextNode);\n    }\n    else {\n        while (node.return) {\n            node = node.return;\n        }\n    }\n    if (node.tag === HostRoot) {\n        // TODO: Check if this was a nested HostRoot when used with\n        // renderContainerIntoSubtree.\n        return nearestMounted;\n    }\n    // If we didn't hit the root, that means that we're in an disconnected tree\n    // that has been unmounted.\n    return null;\n}\nfunction findCurrentFiberUsingSlowPath(fiber) {\n    const alternate = fiber.alternate;\n    if (!alternate) {\n        // If there is no alternate, then we only need to check if it is mounted.\n        const nearestMounted = getNearestMountedFiber(fiber);\n        if (nearestMounted === null) {\n            throw new Error('Unable to find node on an unmounted component.');\n        }\n        if (nearestMounted !== fiber) {\n            return null;\n        }\n        return fiber;\n    }\n    // If we have two possible branches, we'll walk backwards up to the root\n    // to see what path the root points to. On the way we may hit one of the\n    // special cases and we'll deal with them.\n    let a = fiber;\n    let b = alternate;\n    while (true) {\n        const parentA = a.return;\n        if (parentA === null) {\n            // We're at the root.\n            break;\n        }\n        const parentB = parentA.alternate;\n        if (parentB === null) {\n            // There is no alternate. This is an unusual case. Currently, it only\n            // happens when a Suspense component is hidden. An extra fragment fiber\n            // is inserted in between the Suspense fiber and its children. Skip\n            // over this extra fragment fiber and proceed to the next parent.\n            const nextParent = parentA.return;\n            if (nextParent !== null) {\n                a = b = nextParent;\n                continue;\n            }\n            // If there's no parent, we're at the root.\n            break;\n        }\n        // If both copies of the parent fiber point to the same child, we can\n        // assume that the child is current. This happens when we bailout on low\n        // priority: the bailed out fiber's child reuses the current child.\n        if (parentA.child === parentB.child) {\n            let child = parentA.child;\n            while (child) {\n                if (child === a) {\n                    // We've determined that A is the current branch.\n                    //  assertIsMounted(parentA);\n                    return fiber;\n                }\n                if (child === b) {\n                    // We've determined that B is the current branch.\n                    //  assertIsMounted(parentA);\n                    return alternate;\n                }\n                child = child.sibling;\n            }\n            // We should never have an alternate for any mounting node. So the only\n            // way this could possibly happen is if this was unmounted, if at all.\n            throw new Error('Unable to find node on an unmounted component.');\n        }\n        if (a.return !== b.return) {\n            // The return pointer of A and the return pointer of B point to different\n            // fibers. We assume that return pointers never criss-cross, so A must\n            // belong to the child set of A.return, and B must belong to the child\n            // set of B.return.\n            a = parentA;\n            b = parentB;\n        }\n        else {\n            // The return pointers point to the same fiber. We'll have to use the\n            // default, slow path: scan the child sets of each parent alternate to see\n            // which child belongs to which set.\n            //\n            // Search parent A's child set\n            let didFindChild = false;\n            let child = parentA.child;\n            while (child) {\n                if (child === a) {\n                    didFindChild = true;\n                    a = parentA;\n                    b = parentB;\n                    break;\n                }\n                if (child === b) {\n                    didFindChild = true;\n                    b = parentA;\n                    a = parentB;\n                    break;\n                }\n                child = child.sibling;\n            }\n            if (!didFindChild) {\n                // Search parent B's child set\n                child = parentB.child;\n                while (child) {\n                    if (child === a) {\n                        didFindChild = true;\n                        a = parentB;\n                        b = parentA;\n                        break;\n                    }\n                    if (child === b) {\n                        didFindChild = true;\n                        b = parentB;\n                        a = parentA;\n                        break;\n                    }\n                    child = child.sibling;\n                }\n                if (!didFindChild) {\n                    throw new Error('Child was not found in either parent set. This indicates a bug ' +\n                        'in React related to the return pointer. Please file an issue.');\n                }\n            }\n        }\n        if (a.alternate !== b) {\n            throw new Error('Return fibers should always be each others\\' alternates. ' +\n                'This error is likely caused by a bug in React. Please file an issue.');\n        }\n    }\n    // If the root is not a host container, we're in a disconnected tree. I.e.\n    // unmounted.\n    if (a.tag !== HostRoot) {\n        throw new Error('Unable to find node on an unmounted component.');\n    }\n    if (a.stateNode.current === a) {\n        // We've determined that A is the current branch.\n        return fiber;\n    }\n    // Otherwise B has to be current branch.\n    return alternate;\n}\nfunction findCurrentHostFiberImpl(node) {\n    // Next we'll drill down this component to find the first HostComponent/Text.\n    if (node.tag === HostComponent || node.tag === HostText) {\n        return node;\n    }\n    let child = node.child;\n    while (child !== null) {\n        const match = findCurrentHostFiberImpl(child);\n        if (match !== null) {\n            return match;\n        }\n        child = child.sibling;\n    }\n    return null;\n}\nfunction findCurrentHostFiberWithNoPortalsImpl(node) {\n    // Next we'll drill down this component to find the first HostComponent/Text.\n    if (node.tag === HostComponent || node.tag === HostText) {\n        return node;\n    }\n    let child = node.child;\n    while (child !== null) {\n        if (child.tag !== HostPortal) {\n            const match = findCurrentHostFiberWithNoPortalsImpl(child);\n            if (match !== null) {\n                return match;\n            }\n        }\n        child = child.sibling;\n    }\n    return null;\n}\nexports.default = findCurrentFiberUsingSlowPath;\n"],"mappings":"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"}