308c9fdaca4a3a256b46dee12537ea22
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _get = function () {
  function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);
    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);
      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;
      if (getter === undefined) {
        return undefined;
      }
      return getter.call(receiver);
    }
  }
  return get;
}();
var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var _object = require('object.assign');
var _object2 = _interopRequireDefault(_object);
var _arrayPrototype = require('array.prototype.flat');
var _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);
var _has = require('has');
var _has2 = _interopRequireDefault(_has);
var _enzymeShallowEqual = require('enzyme-shallow-equal');
var _enzymeShallowEqual2 = _interopRequireDefault(_enzymeShallowEqual);
var _Utils = require('./Utils');
var _getAdapter = require('./getAdapter');
var _getAdapter2 = _interopRequireDefault(_getAdapter);
var _Debug = require('./Debug');
var _RSTTraversal = require('./RSTTraversal');
var _selectors = require('./selectors');
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    'default': obj
  };
}
function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var NODE = (0, _Utils.sym)('__node__');
var NODES = (0, _Utils.sym)('__nodes__');
var RENDERER = (0, _Utils.sym)('__renderer__');
var UNRENDERED = (0, _Utils.sym)('__unrendered__');
var ROOT = (0, _Utils.sym)('__root__');
var OPTIONS = (0, _Utils.sym)('__options__');
var SET_STATE = (0, _Utils.sym)('__setState__');
var ROOT_NODES = (0, _Utils.sym)('__rootNodes__');
var CHILD_CONTEXT = (0, _Utils.sym)('__childContext__');
var WRAPPING_COMPONENT = (0, _Utils.sym)('__wrappingComponent__');
var PRIMARY_WRAPPER = (0, _Utils.sym)('__primaryWrapper__');
var ROOT_FINDER = (0, _Utils.sym)('__rootFinder__');
var PROVIDER_VALUES = (0, _Utils.sym)('__providerValues__');

/**
 * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate
 * function.
 *
 * @param {ShallowWrapper} wrapper
 * @param {Function} predicate
 * @param {Function} filter
 * @returns {ShallowWrapper}
 */
function findWhereUnwrapped(wrapper, predicate) {
  var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _RSTTraversal.treeFilter;
  return wrapper.flatMap(function (n) {
    return filter(n.getNodeInternal(), predicate);
  });
}

/**
 * Returns a new wrapper instance with only the nodes of the current wrapper instance that match
 * the provided predicate function.
 *
 * @param {ShallowWrapper} wrapper
 * @param {Function} predicate
 * @returns {ShallowWrapper}
 */
function filterWhereUnwrapped(wrapper, predicate) {
  return wrapper.wrap(wrapper.getNodesInternal().filter(predicate).filter(Boolean));
}

/**
 * Ensure options passed to ShallowWrapper are valid. Throws otherwise.
 * @param {Object} options
 */
function validateOptions(options) {
  var lifecycleExperimental = options.lifecycleExperimental,
    disableLifecycleMethods = options.disableLifecycleMethods,
    enableComponentDidUpdateOnSetState = options.enableComponentDidUpdateOnSetState,
    supportPrevContextArgumentOfComponentDidUpdate = options.supportPrevContextArgumentOfComponentDidUpdate,
    lifecycles = options.lifecycles;
  if (typeof lifecycleExperimental !== 'undefined' && typeof lifecycleExperimental !== 'boolean') {
    throw new Error('lifecycleExperimental must be either true or false if provided');
  }
  if (typeof disableLifecycleMethods !== 'undefined' && typeof disableLifecycleMethods !== 'boolean') {
    throw new Error('disableLifecycleMethods must be either true or false if provided');
  }
  if (lifecycleExperimental != null && disableLifecycleMethods != null && lifecycleExperimental === disableLifecycleMethods) {
    throw new Error('lifecycleExperimental and disableLifecycleMethods cannot be set to the same value');
  }
  if (typeof enableComponentDidUpdateOnSetState !== 'undefined' && lifecycles.componentDidUpdate && lifecycles.componentDidUpdate.onSetState !== enableComponentDidUpdateOnSetState) {
    throw new TypeError('the legacy enableComponentDidUpdateOnSetState option should be matched by `lifecycles: { componentDidUpdate: { onSetState: true } }`, for compatibility');
  }
  if (typeof supportPrevContextArgumentOfComponentDidUpdate !== 'undefined' && lifecycles.componentDidUpdate && lifecycles.componentDidUpdate.prevContext !== supportPrevContextArgumentOfComponentDidUpdate) {
    throw new TypeError('the legacy supportPrevContextArgumentOfComponentDidUpdate option should be matched by `lifecycles: { componentDidUpdate: { prevContext: true } }`, for compatibility');
  }
}
function getAdapterLifecycles(_ref) {
  var options = _ref.options;
  var _options$lifecycles = options.lifecycles,
    lifecycles = _options$lifecycles === undefined ? {} : _options$lifecycles,
    enableComponentDidUpdateOnSetState = options.enableComponentDidUpdateOnSetState,
    supportPrevContextArgumentOfComponentDidUpdate = options.supportPrevContextArgumentOfComponentDidUpdate;
  var hasLegacySetStateArg = typeof enableComponentDidUpdateOnSetState !== 'undefined';
  var hasLegacyPrevContextArg = typeof supportPrevContextArgumentOfComponentDidUpdate !== 'undefined';
  var componentDidUpdate = hasLegacySetStateArg || hasLegacyPrevContextArg ? (0, _object2['default'])({}, hasLegacySetStateArg && {
    onSetState: !!enableComponentDidUpdateOnSetState
  }, hasLegacyPrevContextArg && {
    prevContext: !!supportPrevContextArgumentOfComponentDidUpdate
  }) : null;
  var originalGDSFP = lifecycles.getDerivedStateFromProps;
  var getDerivedStateFromProps = originalGDSFP ? {
    hasShouldComponentUpdateBug: !!originalGDSFP.hasShouldComponentUpdateBug
  } : false;
  return (0, _object2['default'])({}, lifecycles, {
    setState: (0, _object2['default'])({}, lifecycles.setState),
    getChildContext: (0, _object2['default'])({
      calledByRenderer: true
    }, lifecycles.getChildContext)
  }, componentDidUpdate && {
    componentDidUpdate: componentDidUpdate
  }, {
    getDerivedStateFromProps: getDerivedStateFromProps
  });
}
function getRootNode(node) {
  if (node.nodeType === 'host') {
    return node;
  }
  return node.rendered;
}
function getRootNodeInternal(wrapper) {
  if (wrapper[ROOT].length !== 1) {
    throw new Error('getRootNodeInternal(wrapper) can only be called when wrapper wraps one node');
  }
  if (wrapper[ROOT] !== wrapper) {
    return wrapper[ROOT_NODES][0];
  }
  return wrapper[ROOT][NODE];
}
function nodeParents(wrapper, node) {
  return (0, _RSTTraversal.parentsOfNode)(node, getRootNodeInternal(wrapper));
}
function privateSetNodes(wrapper, nodes) {
  if (!Array.isArray(nodes)) {
    (0, _Utils.privateSet)(wrapper, NODE, nodes);
    (0, _Utils.privateSet)(wrapper, NODES, [nodes]);
  } else {
    (0, _Utils.privateSet)(wrapper, NODE, nodes[0]);
    (0, _Utils.privateSet)(wrapper, NODES, nodes);
  }
  (0, _Utils.privateSet)(wrapper, 'length', wrapper[NODES].length);
}
function pureComponentShouldComponentUpdate(prevProps, props, prevState, state) {
  return !(0, _enzymeShallowEqual2['default'])(prevProps, props) || !(0, _enzymeShallowEqual2['default'])(prevState, state);
}
function isPureComponent(instance) {
  return instance && instance.isPureReactComponent;
}
function getChildContext(node, hierarchy, renderer) {
  var instance = node.instance,
    Component = node.type;
  var componentName = (0, _Utils.displayNameOfNode)(node);
  // Warn like react if childContextTypes is not defined:
  // https://github.com/facebook/react/blob/1454a8be03794f5e0b23a7e7696cbbbdcf8b0f5d/packages/react-dom/src/server/ReactPartialRenderer.js#L639-L646
  if (_typeof(Component.childContextTypes) !== 'object') {
    // eslint-disable-next-line no-console
    console.warn(String(componentName) + '.getChildContext(): childContextTypes must be defined in order to use getChildContext().');
    return {};
  }
  // Check childContextTypes like react:
  // https://github.com/facebook/react/blob/1454a8be03794f5e0b23a7e7696cbbbdcf8b0f5d/packages/react-dom/src/server/ReactPartialRenderer.js#L630-L637
  var childContext = instance.getChildContext();
  Object.keys(childContext).forEach(function (key) {
    if (!(key in Component.childContextTypes)) {
      throw new Error(String(componentName) + '.getChildContext(): key "' + String(key) + '" is not defined in childContextTypes.');
    }
  });
  if (typeof renderer.checkPropTypes === 'function') {
    renderer.checkPropTypes(Component.childContextTypes, childContext, 'child context', hierarchy);
  }
  return childContext;
}
function spyOnGetChildContextInitialRender(nodes, adapter) {
  if (!(0, _Utils.isCustomComponentElement)(nodes, adapter) || !nodes.type.prototype || typeof nodes.type.prototype.getChildContext !== 'function') {
    return null;
  }
  return (0, _Utils.spyMethod)(nodes.type.prototype, 'getChildContext');
}
function privateSetChildContext(adapter, wrapper, instance, renderedNode, getChildContextSpy) {
  var renderer = wrapper[RENDERER];
  // We only support parent-based context.
  if (adapter.options.legacyContextMode !== 'parent') {
    return;
  }
  if (getChildContextSpy) {
    (0, _Utils.privateSet)(wrapper, CHILD_CONTEXT, getChildContextSpy.getLastReturnValue());
    getChildContextSpy.restore();
  } else if (typeof instance.getChildContext === 'function') {
    // If there's no spy but getChildContext is a function, that means our renderer
    // is not going to call it for us, so we need to call it ourselves.
    var nodeHierarchy = [wrapper[NODE]].concat(nodeParents(wrapper, wrapper[NODE]));
    var childContext = getChildContext(renderedNode, nodeHierarchy, renderer);
    (0, _Utils.privateSet)(wrapper, CHILD_CONTEXT, childContext);
  } else {
    (0, _Utils.privateSet)(wrapper, CHILD_CONTEXT, null);
  }
}
function mockSCUIfgDSFPReturnNonNull(node, state) {
  var getDerivedStateFromProps = node.type.getDerivedStateFromProps;
  if (typeof getDerivedStateFromProps === 'function') {
    // we try to fix a React shallow renderer bug here.
    // (facebook/react#14607, which has been fixed in react 16.8):
    // when gDSFP return derived state, it will set instance state in shallow renderer before SCU,
    // this will cause `this.state` in sCU be the updated state, which is wrong behavior.
    // so we have to wrap sCU to pass the old state to original sCU.
    var instance = node.instance;
    var _spyMethod = (0, _Utils.spyMethod)(instance, 'shouldComponentUpdate', function (originalSCU) {
        return function () {
          function shouldComponentUpdate() {
            instance.state = state;
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            var sCUResult = originalSCU.apply(instance, args);
            var nextState = args[1];
            instance.state = nextState;
            restore();
            return sCUResult;
          }
          return shouldComponentUpdate;
        }();
      }),
      restore = _spyMethod.restore;
  }
}

/**
 * Recursively dive()s every custom component in a wrapper until
 * the target component is found.
 *
 * @param {ShallowWrapper} wrapper A ShallowWrapper to search
 * @param {ComponentType} target A react custom component that, when found, will end recursion
 * @param {Adapter} adapter An Enzyme adapter
 * @returns {ShallowWrapper|undefined} A ShallowWrapper for the target, or
 *  undefined if it can't be found
 */
function deepRender(wrapper, target, adapter) {
  var node = wrapper[NODE];
  var element = node && adapter.nodeToElement(node);
  if (wrapper.type() === target) {
    return wrapper.dive();
  }
  if (element && (0, _Utils.isCustomComponentElement)(element, adapter)) {
    return deepRender(wrapper.dive(), target, adapter);
  }
  var children = wrapper.children();
  for (var i = 0; i < children.length; i += 1) {
    var found = deepRender(children.at(i), target, adapter);
    if (typeof found !== 'undefined') {
      return found;
    }
  }
  return undefined;
}

/**
 * Deep-renders the `wrappingComponent` and returns the context that should
 * be accessible to the primary wrapper.
 *
 * @param {WrappingComponentWrapper} wrapper The `WrappingComponentWrapper` for a
 *  `wrappingComponent`
 * @param {Adapter} adapter An Enzyme adapter
 * @returns {object} An object containing an object of legacy context values and a Map of
 *  `createContext()` Provider values.
 */
function getContextFromWrappingComponent(wrapper, adapter) {
  var rootFinder = deepRender(wrapper, wrapper[ROOT_FINDER], adapter);
  if (!rootFinder) {
    throw new Error('`wrappingComponent` must render its children!');
  }
  return {
    legacyContext: rootFinder[OPTIONS].context,
    providerValues: rootFinder[PROVIDER_VALUES]
  };
}

/**
 * Makes options specifically for `ShallowWrapper`. Most of the logic here is around rendering
 * a `wrappingComponent` (if one was provided) and adding the child context of that component
 * to `options.context`.
 *
 * @param {ReactElement} nodes the nodes passed to `ShallowWrapper`
 * @param {ShallowWrapper} root this `ShallowWrapper`'s parent. If this is passed, options are
 *  not transformed.
 * @param {*} passedOptions the options passed to `ShallowWrapper`.
 * @param {*} wrapper the `ShallowWrapper` itself
 * @returns {Object} the decorated and transformed options
 */
function makeShallowOptions(nodes, root, passedOptions, wrapper) {
  var options = (0, _Utils.makeOptions)(passedOptions);
  var adapter = (0, _getAdapter2['default'])(passedOptions);
  (0, _Utils.privateSet)(options, PROVIDER_VALUES, passedOptions[PROVIDER_VALUES]);
  if (root || !(0, _Utils.isCustomComponent)(options.wrappingComponent, adapter)) {
    return options;
  }
  if (typeof adapter.wrapWithWrappingComponent !== 'function') {
    throw new TypeError('your adapter does not support `wrappingComponent`. Try upgrading it!');
  }
  var _adapter$wrapWithWrap = adapter.wrapWithWrappingComponent(nodes, options),
    wrappedNode = _adapter$wrapWithWrap.node,
    RootFinder = _adapter$wrapWithWrap.RootFinder;
  // eslint-disable-next-line no-use-before-define

  var wrappingComponent = new WrappingComponentWrapper(wrappedNode, wrapper, RootFinder);
  var _getContextFromWrappi = getContextFromWrappingComponent(wrappingComponent, adapter),
    wrappingComponentLegacyContext = _getContextFromWrappi.legacyContext,
    wrappingComponentProviderValues = _getContextFromWrappi.providerValues;
  (0, _Utils.privateSet)(wrapper, WRAPPING_COMPONENT, wrappingComponent);
  return (0, _object2['default'])({}, options, _defineProperty({
    context: (0, _object2['default'])({}, options.context, wrappingComponentLegacyContext)
  }, PROVIDER_VALUES, wrappingComponentProviderValues));
}
function makeInheritedChildOptions(wrapper) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var childOptions = (0, _object2['default'])({}, wrapper[OPTIONS], options, {
    context: options.context || (0, _object2['default'])({}, wrapper[OPTIONS].context, wrapper[ROOT][CHILD_CONTEXT])
  });
  (0, _Utils.privateSet)(childOptions, PROVIDER_VALUES, wrapper[ROOT][PROVIDER_VALUES]);
  return childOptions;
}

/**
 * @class ShallowWrapper
 */

var ShallowWrapper = function () {
  function ShallowWrapper(nodes, root) {
    var _this = this;
    var passedOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    _classCallCheck(this, ShallowWrapper);
    validateOptions(passedOptions);
    var options = makeShallowOptions(nodes, root, passedOptions, this);
    var adapter = (0, _getAdapter2['default'])(options);
    var lifecycles = getAdapterLifecycles(adapter);

    // mounting a ShallowRender component
    if (!root) {
      if (!adapter.isValidElement(nodes)) {
        throw new TypeError('ShallowWrapper can only wrap valid elements');
      }
      var getChildContextSpy = lifecycles.getChildContext.calledByRenderer ? spyOnGetChildContextInitialRender(nodes, adapter) : null;
      (0, _Utils.privateSet)(this, ROOT, this);
      (0, _Utils.privateSet)(this, UNRENDERED, nodes);
      var renderer = adapter.createRenderer((0, _object2['default'])({
        mode: 'shallow'
      }, options));
      (0, _Utils.privateSet)(this, RENDERER, renderer);
      var providerValues = new Map(options[PROVIDER_VALUES] || []);
      this[RENDERER].render(nodes, options.context, {
        providerValues: providerValues
      });
      var renderedNode = this[RENDERER].getNode();
      privateSetNodes(this, getRootNode(renderedNode));
      (0, _Utils.privateSet)(this, OPTIONS, options);
      (0, _Utils.privateSet)(this, PROVIDER_VALUES, providerValues);
      var instance = renderedNode.instance;
      if (instance && !options.disableLifecycleMethods) {
        // Ensure to call componentDidUpdate when instance.setState is called
        if (lifecycles.componentDidUpdate.onSetState && !instance[SET_STATE]) {
          (0, _Utils.privateSet)(instance, SET_STATE, instance.setState);
          instance.setState = function (updater) {
            var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
            return _this.setState.apply(_this, _toConsumableArray(callback == null ? [updater] : [updater, callback]));
          };
        }
        if (typeof instance.componentDidMount === 'function') {
          this[RENDERER].batchedUpdates(function () {
            instance.componentDidMount();
          });
        }
        privateSetChildContext(adapter, this, instance, renderedNode, getChildContextSpy);
      }
      // creating a child component through enzyme's ShallowWrapper APIs.
    } else {
      (0, _Utils.privateSet)(this, ROOT, root);
      (0, _Utils.privateSet)(this, UNRENDERED, null);
      (0, _Utils.privateSet)(this, RENDERER, root[RENDERER]);
      privateSetNodes(this, nodes);
      (0, _Utils.privateSet)(this, OPTIONS, root[OPTIONS]);
      (0, _Utils.privateSet)(this, ROOT_NODES, root[NODES]);
      (0, _Utils.privateSet)(this, PROVIDER_VALUES, null);
    }
  }

  /**
   * Returns the root wrapper
   *
   * @return {ShallowWrapper}
   */

  _createClass(ShallowWrapper, [{
    key: 'root',
    value: function () {
      function root() {
        return this[ROOT];
      }
      return root;
    }()

    /**
     * Returns the wrapped component.
     *
     * @return {ReactComponent}
     */
  }, {
    key: 'getNodeInternal',
    value: function () {
      function getNodeInternal() {
        if (this.length !== 1) {
          throw new Error('ShallowWrapper::getNode() can only be called when wrapping one node');
        }
        if (this[ROOT] === this) {
          this.update();
        }
        return this[NODE];
      }
      return getNodeInternal;
    }()

    /**
     * Returns the the wrapped components.
     *
     * @return {Array<ReactComponent>}
     */
  }, {
    key: 'getNodesInternal',
    value: function () {
      function getNodesInternal() {
        if (this[ROOT] === this && this.length === 1) {
          this.update();
        }
        return this[NODES];
      }
      return getNodesInternal;
    }()

    /**
     * Returns the wrapped ReactElement.
     *
     * @return {ReactElement}
     */
  }, {
    key: 'getElement',
    value: function () {
      function getElement() {
        var _this2 = this;
        return this.single('getElement', function (n) {
          return (0, _getAdapter2['default'])(_this2[OPTIONS]).nodeToElement(n);
        });
      }
      return getElement;
    }()

    /**
     * Returns the wrapped ReactElements.
     *
     * @return {Array<ReactElement>}
     */
  }, {
    key: 'getElements',
    value: function () {
      function getElements() {
        var _this3 = this;
        return this.getNodesInternal().map(function (n) {
          return (0, _getAdapter2['default'])(_this3[OPTIONS]).nodeToElement(n);
        });
      }
      return getElements;
    }()

    // eslint-disable-next-line class-methods-use-this
  }, {
    key: 'getNode',
    value: function () {
      function getNode() {
        throw new Error('ShallowWrapper::getNode() is no longer supported. Use ShallowWrapper::getElement() instead');
      }
      return getNode;
    }()

    // eslint-disable-next-line class-methods-use-this
  }, {
    key: 'getNodes',
    value: function () {
      function getNodes() {
        throw new Error('ShallowWrapper::getNodes() is no longer supported. Use ShallowWrapper::getElements() instead');
      }
      return getNodes;
    }()

    /**
     * Gets the instance of the component being rendered as the root node passed into `shallow()`.
     *
     * NOTE: can only be called on a wrapper instance that is also the root instance.
     *
     * Example:
     * ```
     * const wrapper = shallow(<MyComponent />);
     * const inst = wrapper.instance();
     * expect(inst).to.be.instanceOf(MyComponent);
     * ```
     * @returns {ReactComponent}
     */
  }, {
    key: 'instance',
    value: function () {
      function instance() {
        if (this[ROOT] !== this) {
          throw new Error('ShallowWrapper::instance() can only be called on the root');
        }
        return this[RENDERER].getNode().instance;
      }
      return instance;
    }()

    /**
     * If a `wrappingComponent` was passed in `options`, this methods returns a `ShallowWrapper`
     * around the rendered `wrappingComponent`. This `ShallowWrapper` can be used to update the
     * `wrappingComponent`'s props, state, etc.
     *
     * @returns ShallowWrapper
     */
  }, {
    key: 'getWrappingComponent',
    value: function () {
      function getWrappingComponent() {
        if (this[ROOT] !== this) {
          throw new Error('ShallowWrapper::getWrappingComponent() can only be called on the root');
        }
        if (!this[OPTIONS].wrappingComponent) {
          throw new Error('ShallowWrapper::getWrappingComponent() can only be called on a wrapper that was originally passed a `wrappingComponent` option');
        }
        return this[WRAPPING_COMPONENT];
      }
      return getWrappingComponent;
    }()

    /**
     * Forces a re-render. Useful to run before checking the render output if something external
     * may be updating the state of the component somewhere.
     *
     * NOTE: can only be called on a wrapper instance that is also the root instance.
     *
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'update',
    value: function () {
      function update() {
        if (this[ROOT] !== this) {
          throw new Error('ShallowWrapper::update() can only be called on the root');
        }
        if (this.length !== 1) {
          throw new Error('ShallowWrapper::update() can only be called when wrapping one node');
        }
        privateSetNodes(this, getRootNode(this[RENDERER].getNode()));
        return this;
      }
      return update;
    }()

    /**
     * A method that unmounts the component. This can be used to simulate a component going through
     * and unmount/mount lifecycle.
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'unmount',
    value: function () {
      function unmount() {
        this[RENDERER].unmount();
        if (this[ROOT][WRAPPING_COMPONENT]) {
          this[ROOT][WRAPPING_COMPONENT].unmount();
        }
        return this;
      }
      return unmount;
    }()

    /**
     * A method is for re-render with new props and context.
     * This calls componentDidUpdate method if disableLifecycleMethods is not enabled.
     *
     * NOTE: can only be called on a wrapper instance that is also the root instance.
     *
     * @param {Object} props
     * @param {Object} context
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'rerender',
    value: function () {
      function rerender(props, context) {
        var _this4 = this;
        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);
        this.single('rerender', function () {
          (0, _Utils.withSetStateAllowed)(function () {
            // NOTE(lmr): In react 16, instances will be null for SFCs, but
            // rerendering with props/context is still a valid thing to do. In
            // this case, state will be undefined, but props/context will exist.
            var node = _this4[RENDERER].getNode();
            var instance = node.instance || {};
            var type = node.type || {};
            var state = instance.state;
            var prevProps = instance.props || _this4[UNRENDERED].props;
            var prevContext = instance.context || _this4[OPTIONS].context;
            var nextContext = context || prevContext;
            if (context) {
              _this4[OPTIONS] = (0, _object2['default'])({}, _this4[OPTIONS], {
                context: nextContext
              });
            }
            _this4[RENDERER].batchedUpdates(function () {
              // When shouldComponentUpdate returns false we shouldn't call componentDidUpdate.
              // so we spy shouldComponentUpdate to get the result.
              var lifecycles = getAdapterLifecycles(adapter);
              var shouldRender = true;
              var shouldComponentUpdateSpy = void 0;
              var getChildContextSpy = void 0;
              if (!_this4[OPTIONS].disableLifecycleMethods && instance) {
                if (typeof instance.shouldComponentUpdate === 'function') {
                  var gDSFP = lifecycles.getDerivedStateFromProps;
                  if (gDSFP && gDSFP.hasShouldComponentUpdateBug) {
                    mockSCUIfgDSFPReturnNonNull(node, state);
                  }
                  shouldComponentUpdateSpy = (0, _Utils.spyMethod)(instance, 'shouldComponentUpdate');
                }
                if (lifecycles.getChildContext.calledByRenderer && typeof instance.getChildContext === 'function') {
                  getChildContextSpy = (0, _Utils.spyMethod)(instance, 'getChildContext');
                }
              }
              if (!shouldComponentUpdateSpy && isPureComponent(instance)) {
                shouldRender = pureComponentShouldComponentUpdate(prevProps, props, state, instance.state);
              }
              if (props) _this4[UNRENDERED] = (0, _Utils.cloneElement)(adapter, _this4[UNRENDERED], props);
              _this4[RENDERER].render(_this4[UNRENDERED], nextContext, {
                providerValues: _this4[PROVIDER_VALUES]
              });
              if (shouldComponentUpdateSpy) {
                shouldRender = shouldComponentUpdateSpy.getLastReturnValue();
                shouldComponentUpdateSpy.restore();
              }
              if (shouldRender && !_this4[OPTIONS].disableLifecycleMethods && instance) {
                privateSetChildContext(adapter, _this4, instance, node, getChildContextSpy);
                if (lifecycles.getSnapshotBeforeUpdate) {
                  var snapshot = void 0;
                  if (typeof instance.getSnapshotBeforeUpdate === 'function') {
                    snapshot = instance.getSnapshotBeforeUpdate(prevProps, state);
                  }
                  if (lifecycles.componentDidUpdate && typeof instance.componentDidUpdate === 'function' && (!state || (0, _enzymeShallowEqual2['default'])(state, _this4.instance().state) || typeof type.getDerivedStateFromProps === 'function')) {
                    instance.componentDidUpdate(prevProps, state, snapshot);
                  }
                } else if (lifecycles.componentDidUpdate && typeof instance.componentDidUpdate === 'function') {
                  if (lifecycles.componentDidUpdate.prevContext) {
                    instance.componentDidUpdate(prevProps, state, prevContext);
                  } else if (!state || (0, _enzymeShallowEqual2['default'])(_this4.instance().state, state)) {
                    instance.componentDidUpdate(prevProps, state);
                  }
                }
                // If it doesn't need to rerender, update only its props.
              } else if (!(0, _enzymeShallowEqual2['default'])(props, instance.props)) {
                instance.props = (Object.freeze || Object)((0, _object2['default'])({}, instance.props, props));
              }
              _this4.update();
            });
          });
        });
        return this;
      }
      return rerender;
    }()

    /**
     * A method that sets the props of the root component, and re-renders. Useful for when you are
     * wanting to test how the component behaves over time with changing props. Calling this, for
     * instance, will call the `componentWillReceiveProps` lifecycle method.
     *
     * Similar to `setState`, this method accepts a props object and will merge it in with the already
     * existing props.
     *
     * NOTE: can only be called on a wrapper instance that is also the root instance.
     *
     * @param {Object} props object
     * @param {Function} cb - callback function
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'setProps',
    value: function () {
      function setProps(props) {
        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        if (this[ROOT] !== this) {
          throw new Error('ShallowWrapper::setProps() can only be called on the root');
        }
        if (arguments.length > 1 && typeof callback !== 'function') {
          throw new TypeError('ReactWrapper::setProps() expects a function as its second argument');
        }
        this.rerender(props);
        if (callback) {
          callback();
        }
        return this;
      }
      return setProps;
    }()

    /**
     * A method to invoke `setState` on the root component instance similar to how you might in the
     * definition of the component, and re-renders.  This method is useful for testing your component
     * in hard to achieve states, however should be used sparingly. If possible, you should utilize
     * your component's external API in order to get it into whatever state you want to test, in order
     * to be as accurate of a test as possible. This is not always practical, however.
     *
     * NOTE: can only be called on a wrapper instance that is also the root instance.
     *
     * @param {Object} state to merge
     * @param {Function} cb - callback function
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'setState',
    value: function () {
      function setState(state) {
        var _this5 = this;
        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        if (this[ROOT] !== this) {
          throw new Error('ShallowWrapper::setState() can only be called on the root');
        }
        if (this.instance() === null || this[RENDERER].getNode().nodeType !== 'class') {
          throw new Error('ShallowWrapper::setState() can only be called on class components');
        }
        if (arguments.length > 1 && typeof callback !== 'function') {
          throw new TypeError('ReactWrapper::setState() expects a function as its second argument');
        }
        this.single('setState', function () {
          (0, _Utils.withSetStateAllowed)(function () {
            var adapter = (0, _getAdapter2['default'])(_this5[OPTIONS]);
            var lifecycles = getAdapterLifecycles(adapter);
            var node = _this5[RENDERER].getNode();
            var instance = node.instance;
            var prevProps = instance.props;
            var prevState = instance.state;
            var prevContext = instance.context;
            var statePayload = typeof state === 'function' ? state.call(instance, prevState, prevProps) : state;

            // returning null or undefined prevents the update in React 16+
            // https://github.com/facebook/react/pull/12756
            var maybeHasUpdate = !lifecycles.setState.skipsComponentDidUpdateOnNullish || statePayload != null;

            // When shouldComponentUpdate returns false we shouldn't call componentDidUpdate.
            // so we spy shouldComponentUpdate to get the result.
            var shouldComponentUpdateSpy = void 0;
            var getChildContextSpy = void 0;
            var shouldRender = true;
            if (!_this5[OPTIONS].disableLifecycleMethods && instance) {
              if (lifecycles.componentDidUpdate && lifecycles.componentDidUpdate.onSetState && typeof instance.shouldComponentUpdate === 'function') {
                var gDSFP = lifecycles.getDerivedStateFromProps;
                if (gDSFP && gDSFP.hasShouldComponentUpdateBug) {
                  mockSCUIfgDSFPReturnNonNull(node, state);
                }
                shouldComponentUpdateSpy = (0, _Utils.spyMethod)(instance, 'shouldComponentUpdate');
              }
              if (lifecycles.getChildContext.calledByRenderer && typeof instance.getChildContext === 'function') {
                getChildContextSpy = (0, _Utils.spyMethod)(instance, 'getChildContext');
              }
            }
            if (!shouldComponentUpdateSpy && isPureComponent(instance)) {
              shouldRender = pureComponentShouldComponentUpdate(prevProps, instance.props, prevState, (0, _object2['default'])({}, prevState, statePayload));
            }

            // We don't pass the setState callback here
            // to guarantee to call the callback after finishing the render
            if (instance[SET_STATE]) {
              instance[SET_STATE](statePayload);
            } else {
              instance.setState(statePayload);
            }
            if (shouldComponentUpdateSpy) {
              shouldRender = shouldComponentUpdateSpy.getLastReturnValue();
              shouldComponentUpdateSpy.restore();
            }
            if (maybeHasUpdate && shouldRender && !_this5[OPTIONS].disableLifecycleMethods) {
              privateSetChildContext(adapter, _this5, instance, node, getChildContextSpy);
              if (lifecycles.componentDidUpdate && lifecycles.componentDidUpdate.onSetState) {
                if (lifecycles.getSnapshotBeforeUpdate && typeof instance.getSnapshotBeforeUpdate === 'function') {
                  var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);
                  if (typeof instance.componentDidUpdate === 'function') {
                    instance.componentDidUpdate(prevProps, prevState, snapshot);
                  }
                } else if (typeof instance.componentDidUpdate === 'function') {
                  if (lifecycles.componentDidUpdate.prevContext) {
                    instance.componentDidUpdate(prevProps, prevState, prevContext);
                  } else {
                    instance.componentDidUpdate(prevProps, prevState);
                  }
                }
              }
            }
            _this5.update();
            // call the setState callback
            if (callback) {
              if (adapter.invokeSetStateCallback) {
                adapter.invokeSetStateCallback(instance, callback);
              } else {
                callback.call(instance);
              }
            }
          });
        });
        return this;
      }
      return setState;
    }()

    /**
     * A method that sets the context of the root component, and re-renders. Useful for when you are
     * wanting to test how the component behaves over time with changing contexts.
     *
     * NOTE: can only be called on a wrapper instance that is also the root instance.
     *
     * @param {Object} context object
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'setContext',
    value: function () {
      function setContext(context) {
        if (this[ROOT] !== this) {
          throw new Error('ShallowWrapper::setContext() can only be called on the root');
        }
        if (!this[OPTIONS].context) {
          throw new Error('ShallowWrapper::setContext() can only be called on a wrapper that was originally passed a context option');
        }
        return this.rerender(null, context);
      }
      return setContext;
    }()

    /**
     * Whether or not a given react element exists in the shallow render tree.
     *
     * Example:
     * ```
     * const wrapper = shallow(<MyComponent />);
     * expect(wrapper.contains(<div className="foo bar" />)).to.equal(true);
     * ```
     *
     * @param {ReactElement|Array<ReactElement>} nodeOrNodes
     * @returns {Boolean}
     */
  }, {
    key: 'contains',
    value: function () {
      function contains(nodeOrNodes) {
        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);
        if (!(0, _Utils.isReactElementAlike)(nodeOrNodes, adapter)) {
          throw new Error('ShallowWrapper::contains() can only be called with a ReactElement (or an array of them), a string, or a number as an argument.');
        }
        var predicate = Array.isArray(nodeOrNodes) ? function (other) {
          return (0, _Utils.containsChildrenSubArray)(_Utils.nodeEqual, other, nodeOrNodes.map(function (node) {
            return adapter.elementToNode(node);
          }));
        } : function (other) {
          return (0, _Utils.nodeEqual)(adapter.elementToNode(nodeOrNodes), other);
        };
        return findWhereUnwrapped(this, predicate).length > 0;
      }
      return contains;
    }()

    /**
     * Whether or not a given react element exists in the shallow render tree.
     * Match is based on the expected element and not on wrappers element.
     * It will determine if one of the wrappers element "looks like" the expected
     * element by checking if all props of the expected element are present
     * on the wrappers element and equals to each other.
     *
     * Example:
     * ```
     * // MyComponent outputs <div><div class="foo">Hello</div></div>
     * const wrapper = shallow(<MyComponent />);
     * expect(wrapper.containsMatchingElement(<div>Hello</div>)).to.equal(true);
     * ```
     *
     * @param {ReactElement} node
     * @returns {Boolean}
     */
  }, {
    key: 'containsMatchingElement',
    value: function () {
      function containsMatchingElement(node) {
        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);
        var rstNode = adapter.elementToNode(node);
        var predicate = function () {
          function predicate(other) {
            return (0, _Utils.nodeMatches)(rstNode, other, function (a, b) {
              return a <= b;
            });
          }
          return predicate;
        }();
        return findWhereUnwrapped(this, predicate).length > 0;
      }
      return containsMatchingElement;
    }()

    /**
     * Whether or not all the given react elements exist in the shallow render tree.
     * Match is based on the expected element and not on wrappers element.
     * It will determine if one of the wrappers element "looks like" the expected
     * element by checking if all props of the expected element are present
     * on the wrappers element and equals to each other.
     *
     * Example:
     * ```
     * const wrapper = shallow(<MyComponent />);
     * expect(wrapper.containsAllMatchingElements([
     *   <div>Hello</div>,
     *   <div>Goodbye</div>,
     * ])).to.equal(true);
     * ```
     *
     * @param {Array<ReactElement>} nodes
     * @returns {Boolean}
     */
  }, {
    key: 'containsAllMatchingElements',
    value: function () {
      function containsAllMatchingElements(nodes) {
        var _this6 = this;
        if (!Array.isArray(nodes)) {
          throw new TypeError('nodes should be an Array');
        }
        return nodes.every(function (node) {
          return _this6.containsMatchingElement(node);
        });
      }
      return containsAllMatchingElements;
    }()

    /**
     * Whether or not one of the given react elements exists in the shallow render tree.
     * Match is based on the expected element and not on wrappers element.
     * It will determine if one of the wrappers element "looks like" the expected
     * element by checking if all props of the expected element are present
     * on the wrappers element and equals to each other.
     *
     * Example:
     * ```
     * const wrapper = shallow(<MyComponent />);
     * expect(wrapper.containsAnyMatchingElements([
     *   <div>Hello</div>,
     *   <div>Goodbye</div>,
     * ])).to.equal(true);
     * ```
     *
     * @param {Array<ReactElement>} nodes
     * @returns {Boolean}
     */
  }, {
    key: 'containsAnyMatchingElements',
    value: function () {
      function containsAnyMatchingElements(nodes) {
        var _this7 = this;
        return Array.isArray(nodes) && nodes.some(function (node) {
          return _this7.containsMatchingElement(node);
        });
      }
      return containsAnyMatchingElements;
    }()

    /**
     * Whether or not a given react element exists in the render tree.
     *
     * Example:
     * ```
     * const wrapper = shallow(<MyComponent />);
     * expect(wrapper.contains(<div className="foo bar" />)).to.equal(true);
     * ```
     *
     * @param {ReactElement} node
     * @returns {Boolean}
     */
  }, {
    key: 'equals',
    value: function () {
      function equals(node) {
        var _this8 = this;
        return this.single('equals', function () {
          return (0, _Utils.nodeEqual)(_this8.getNodeInternal(), node);
        });
      }
      return equals;
    }()

    /**
     * Whether or not a given react element matches the render tree.
     * Match is based on the expected element and not on wrapper root node.
     * It will determine if the wrapper root node "looks like" the expected
     * element by checking if all props of the expected element are present
     * on the wrapper root node and equals to each other.
     *
     * Example:
     * ```
     * // MyComponent outputs <div class="foo">Hello</div>
     * const wrapper = shallow(<MyComponent />);
     * expect(wrapper.matchesElement(<div>Hello</div>)).to.equal(true);
     * ```
     *
     * @param {ReactElement} node
     * @returns {Boolean}
     */
  }, {
    key: 'matchesElement',
    value: function () {
      function matchesElement(node) {
        var _this9 = this;
        return this.single('matchesElement', function () {
          var adapter = (0, _getAdapter2['default'])(_this9[OPTIONS]);
          var rstNode = adapter.elementToNode(node);
          return (0, _Utils.nodeMatches)(rstNode, _this9.getNodeInternal(), function (a, b) {
            return a <= b;
          });
        });
      }
      return matchesElement;
    }()

    /**
     * Finds every node in the render tree of the current wrapper that matches the provided selector.
     *
     * @param {EnzymeSelector} selector
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'find',
    value: function () {
      function find(selector) {
        return this.wrap((0, _selectors.reduceTreesBySelector)(selector, this.getNodesInternal()));
      }
      return find;
    }()

    /**
     * Returns whether or not current node matches a provided selector.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @param {EnzymeSelector} selector
     * @returns {boolean}
     */
  }, {
    key: 'is',
    value: function () {
      function is(selector) {
        var predicate = (0, _selectors.buildPredicate)(selector);
        return this.single('is', function (n) {
          return predicate(n);
        });
      }
      return is;
    }()

    /**
     * Returns true if the component rendered nothing, i.e., null or false.
     *
     * @returns {boolean}
     */
  }, {
    key: 'isEmptyRender',
    value: function () {
      function isEmptyRender() {
        var nodes = this.getNodesInternal();
        return nodes.every(function (n) {
          return (0, _Utils.isEmptyValue)(n);
        });
      }
      return isEmptyRender;
    }()

    /**
     * Returns a new wrapper instance with only the nodes of the current wrapper instance that match
     * the provided predicate function. The predicate should receive a wrapped node as its first
     * argument.
     *
     * @param {Function} predicate
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'filterWhere',
    value: function () {
      function filterWhere(predicate) {
        var _this10 = this;
        return filterWhereUnwrapped(this, function (n) {
          return predicate(_this10.wrap(n));
        });
      }
      return filterWhere;
    }()

    /**
     * Returns a new wrapper instance with only the nodes of the current wrapper instance that match
     * the provided selector.
     *
     * @param {EnzymeSelector} selector
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'filter',
    value: function () {
      function filter(selector) {
        var predicate = (0, _selectors.buildPredicate)(selector);
        return filterWhereUnwrapped(this, predicate);
      }
      return filter;
    }()

    /**
     * Returns a new wrapper instance with only the nodes of the current wrapper that did not match
     * the provided selector. Essentially the inverse of `filter`.
     *
     * @param {EnzymeSelector} selector
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'not',
    value: function () {
      function not(selector) {
        var predicate = (0, _selectors.buildPredicate)(selector);
        return filterWhereUnwrapped(this, function (n) {
          return !predicate(n);
        });
      }
      return not;
    }()

    /**
     * Returns a string of the rendered text of the current render tree.  This function should be
     * looked at with skepticism if being used to test what the actual HTML output of the component
     * will be. If that is what you would like to test, use enzyme's `render` function instead.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @returns {String}
     */
  }, {
    key: 'text',
    value: function () {
      function text() {
        return this.single('text', _RSTTraversal.getTextFromNode);
      }
      return text;
    }()

    /**
     * Returns the HTML of the node.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @returns {String}
     */
  }, {
    key: 'html',
    value: function () {
      function html() {
        var _this11 = this;
        return this.single('html', function (n) {
          if (_this11.type() === null) return null;
          var adapter = (0, _getAdapter2['default'])(_this11[OPTIONS]);
          var renderer = adapter.createRenderer((0, _object2['default'])({}, _this11[OPTIONS], {
            mode: 'string'
          }));
          return renderer.render(adapter.nodeToElement(n));
        });
      }
      return html;
    }()

    /**
     * Returns the current node rendered to HTML and wrapped in a CheerioWrapper.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @returns {CheerioWrapper}
     */
  }, {
    key: 'render',
    value: function () {
      function render() {
        var html = this.html();
        return (0, _Utils.loadCheerioRoot)(html);
      }
      return render;
    }()

    /**
     * Used to simulate events. Pass an eventname and (optionally) event arguments. This method of
     * testing events should be met with some skepticism.
     *
     * @param {String} event
     * @param {Array} args
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'simulate',
    value: function () {
      function simulate(event) {
        var _this12 = this;
        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        return this.single('simulate', function (n) {
          var _RENDERER;
          (_RENDERER = _this12[RENDERER]).simulateEvent.apply(_RENDERER, [n, event].concat(args));
          _this12[ROOT].update();
          return _this12;
        });
      }
      return simulate;
    }()

    /**
     * Used to simulate throwing a rendering error. Pass an error to throw.
     *
     * @param {String} error
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'simulateError',
    value: function () {
      function simulateError(error) {
        var _this13 = this;

        // in shallow, the "root" is the "rendered" thing.

        return this.single('simulateError', function (thisNode) {
          if (thisNode.nodeType === 'host') {
            throw new TypeError('ShallowWrapper::simulateError() can only be called on custom components');
          }
          var renderer = _this13[RENDERER];
          if (typeof renderer.simulateError !== 'function') {
            throw new TypeError('your adapter does not support `simulateError`. Try upgrading it!');
          }
          var rootNode = getRootNodeInternal(_this13);
          var nodeHierarchy = [thisNode].concat(nodeParents(_this13, thisNode));
          renderer.simulateError(nodeHierarchy, rootNode, error);
          return _this13;
        });
      }
      return simulateError;
    }()

    /**
     * Returns the props hash for the current node of the wrapper.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @returns {Object}
     */
  }, {
    key: 'props',
    value: function () {
      function props() {
        return this.single('props', _RSTTraversal.propsOfNode);
      }
      return props;
    }()

    /**
     * Returns the state hash for the root node of the wrapper. Optionally pass in a prop name and it
     * will return just that value.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @param {String} name (optional)
     * @returns {*}
     */
  }, {
    key: 'state',
    value: function () {
      function state(name) {
        var _this14 = this;
        if (this[ROOT] !== this) {
          throw new Error('ShallowWrapper::state() can only be called on the root');
        }
        if (this.instance() === null || this[RENDERER].getNode().nodeType !== 'class') {
          throw new Error('ShallowWrapper::state() can only be called on class components');
        }
        var _state = this.single('state', function () {
          return _this14.instance().state;
        });
        if (typeof name !== 'undefined') {
          if (_state == null) {
            throw new TypeError('ShallowWrapper::state("' + String(name) + '") requires that `state` not be `null` or `undefined`');
          }
          return _state[name];
        }
        return _state;
      }
      return state;
    }()

    /**
     * Returns the context hash for the root node of the wrapper.
     * Optionally pass in a prop name and it will return just that value.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @param {String} name (optional)
     * @returns {*}
     */
  }, {
    key: 'context',
    value: function () {
      function context(name) {
        var _this15 = this;
        if (this[ROOT] !== this) {
          throw new Error('ShallowWrapper::context() can only be called on the root');
        }
        if (!this[OPTIONS].context) {
          throw new Error('ShallowWrapper::context() can only be called on a wrapper that was originally passed a context option');
        }
        if (this.instance() === null) {
          throw new Error('ShallowWrapper::context() can only be called on wrapped nodes that have a non-null instance');
        }
        var _context = this.single('context', function () {
          return _this15.instance().context;
        });
        if (name) {
          return _context[name];
        }
        return _context;
      }
      return context;
    }()

    /**
     * Returns a new wrapper with all of the children of the current wrapper.
     *
     * @param {EnzymeSelector} [selector]
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'children',
    value: function () {
      function children(selector) {
        var allChildren = this.flatMap(function (n) {
          return (0, _RSTTraversal.childrenOfNode)(n.getNodeInternal());
        });
        return selector ? allChildren.filter(selector) : allChildren;
      }
      return children;
    }()

    /**
     * Returns a new wrapper with a specific child
     *
     * @param {Number} [index]
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'childAt',
    value: function () {
      function childAt(index) {
        var _this16 = this;
        return this.single('childAt', function () {
          return _this16.children().at(index);
        });
      }
      return childAt;
    }()

    /**
     * Returns a wrapper around all of the parents/ancestors of the wrapper. Does not include the node
     * in the current wrapper.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @param {EnzymeSelector} [selector]
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'parents',
    value: function () {
      function parents(selector) {
        var _this17 = this;
        return this.single('parents', function (n) {
          var allParents = _this17.wrap(nodeParents(_this17, n));
          return selector ? allParents.filter(selector) : allParents;
        });
      }
      return parents;
    }()

    /**
     * Returns a wrapper around the immediate parent of the current node.
     *
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'parent',
    value: function () {
      function parent() {
        return this.flatMap(function (n) {
          return [n.parents().get(0)];
        });
      }
      return parent;
    }()

    /**
     *
     * @param {EnzymeSelector} selector
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'closest',
    value: function () {
      function closest(selector) {
        if (this.is(selector)) {
          return this;
        }
        var matchingAncestors = this.parents().filter(selector);
        return matchingAncestors.length > 0 ? matchingAncestors.first() : this.findWhere(function () {
          return false;
        });
      }
      return closest;
    }()

    /**
     * Shallow renders the current node and returns a shallow wrapper around it.
     *
     * NOTE: can only be called on wrapper of a single node.
     *
     * @param {Object} options
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'shallow',
    value: function () {
      function shallow() {
        var _this18 = this;
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return this.single('shallow', function (n) {
          var childOptions = makeInheritedChildOptions(_this18, options);
          return _this18.wrap((0, _getAdapter2['default'])(_this18[OPTIONS]).nodeToElement(n), null, childOptions);
        });
      }
      return shallow;
    }()

    /**
     * Returns the value of prop with the given name of the current node.
     *
     * @param propName
     * @returns {*}
     */
  }, {
    key: 'prop',
    value: function () {
      function prop(propName) {
        return this.props()[propName];
      }
      return prop;
    }()

    /**
     * Used to invoke a function prop.
     * Will invoke an function prop and return its value.
     *
     * @param {String} propName
     * @returns {Any}
     */
  }, {
    key: 'invoke',
    value: function () {
      function invoke(propName) {
        var _this19 = this;
        return this.single('invoke', function () {
          var handler = _this19.prop(propName);
          if (typeof handler !== 'function') {
            throw new TypeError('ShallowWrapper::invoke() requires the name of a prop whose value is a function');
          }
          return function () {
            var response = handler.apply(undefined, arguments);
            _this19[ROOT].update();
            return response;
          };
        });
      }
      return invoke;
    }()

    /**
     * Returns a wrapper of the node rendered by the provided render prop.
     *
     * @param {String} propName
     * @returns {Function}
     */
  }, {
    key: 'renderProp',
    value: function () {
      function renderProp(propName) {
        var _this20 = this;
        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);
        if (typeof adapter.wrap !== 'function') {
          throw new RangeError('your adapter does not support `wrap`. Try upgrading it!');
        }
        return this.single('renderProp', function (n) {
          if (n.nodeType === 'host') {
            throw new TypeError('ShallowWrapper::renderProp() can only be called on custom components');
          }
          if (typeof propName !== 'string') {
            throw new TypeError('ShallowWrapper::renderProp(): `propName` must be a string');
          }
          var props = _this20.props();
          if (!(0, _has2['default'])(props, propName)) {
            throw new Error('ShallowWrapper::renderProp(): no prop called \u201C' + String(propName) + '\u201C found');
          }
          var propValue = props[propName];
          if (typeof propValue !== 'function') {
            throw new TypeError('ShallowWrapper::renderProp(): expected prop \u201C' + String(propName) + '\u201C to contain a function, but it holds \u201C' + (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) + '\u201C');
          }
          return function () {
            var element = propValue.apply(undefined, arguments);
            var wrapped = adapter.wrap(element);
            return _this20.wrap(wrapped, null, _this20[OPTIONS]);
          };
        });
      }
      return renderProp;
    }()

    /**
     * Returns the key assigned to the current node.
     *
     * @returns {String}
     */
  }, {
    key: 'key',
    value: function () {
      function key() {
        return this.single('key', function (n) {
          return n.key === undefined ? null : n.key;
        });
      }
      return key;
    }()

    /**
     * Returns the type of the current node of this wrapper. If it's a composite component, this will
     * be the component constructor. If it's a native DOM node, it will be a string of the tag name.
     * If it's null, it will be null.
     *
     * @returns {String|Function|null}
     */
  }, {
    key: 'type',
    value: function () {
      function type() {
        return this.single('type', function (n) {
          return (0, _Utils.typeOfNode)(n);
        });
      }
      return type;
    }()

    /**
     * Returns the name of the current node of this wrapper.
     *
     * In order of precedence => type.displayName -> type.name -> type.
     *
     * @returns {String}
     */
  }, {
    key: 'name',
    value: function () {
      function name() {
        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);
        return this.single('name', function (n) {
          return adapter.displayNameOfNode ? adapter.displayNameOfNode(n) : (0, _Utils.displayNameOfNode)(n);
        });
      }
      return name;
    }()

    /**
     * Returns whether or not the current node has the given class name or not.
     *
     * NOTE: can only be called on a wrapper of a single node.
     *
     * @param className
     * @returns {Boolean}
     */
  }, {
    key: 'hasClass',
    value: function () {
      function hasClass(className) {
        if (typeof className === 'string' && className.indexOf('.') !== -1) {
          // eslint-disable-next-line no-console
          console.warn('It looks like you\'re calling `ShallowWrapper::hasClass()` with a CSS selector. hasClass() expects a class name, not a CSS selector.');
        }
        return this.single('hasClass', function (n) {
          return (0, _RSTTraversal.hasClassName)(n, className);
        });
      }
      return hasClass;
    }()

    /**
     * Iterates through each node of the current wrapper and executes the provided function with a
     * wrapper around the corresponding node passed in as the first argument.
     *
     * @param {Function} fn
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'forEach',
    value: function () {
      function forEach(fn) {
        var _this21 = this;
        this.getNodesInternal().forEach(function (n, i) {
          return fn.call(_this21, _this21.wrap(n), i);
        });
        return this;
      }
      return forEach;
    }()

    /**
     * Maps the current array of nodes to another array. Each node is passed in as a `ShallowWrapper`
     * to the map function.
     *
     * @param {Function} fn
     * @returns {Array}
     */
  }, {
    key: 'map',
    value: function () {
      function map(fn) {
        var _this22 = this;
        return this.getNodesInternal().map(function (n, i) {
          return fn.call(_this22, _this22.wrap(n), i);
        });
      }
      return map;
    }()

    /**
     * Reduces the current array of nodes to a value. Each node is passed in as a `ShallowWrapper`
     * to the reducer function.
     *
     * @param {Function} fn - the reducer function
     * @param {*} initialValue - the initial value
     * @returns {*}
     */
  }, {
    key: 'reduce',
    value: function () {
      function reduce(fn) {
        var _this23 = this;
        var initialValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        if (arguments.length > 1) {
          return this.getNodesInternal().reduce(function (accum, n, i) {
            return fn.call(_this23, accum, _this23.wrap(n), i);
          }, initialValue);
        }
        return this.getNodesInternal().reduce(function (accum, n, i) {
          return fn.call(_this23, i === 1 ? _this23.wrap(accum) : accum, _this23.wrap(n), i);
        });
      }
      return reduce;
    }()

    /**
     * Reduces the current array of nodes to another array, from right to left. Each node is passed
     * in as a `ShallowWrapper` to the reducer function.
     *
     * @param {Function} fn - the reducer function
     * @param {*} initialValue - the initial value
     * @returns {*}
     */
  }, {
    key: 'reduceRight',
    value: function () {
      function reduceRight(fn) {
        var _this24 = this;
        var initialValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
        if (arguments.length > 1) {
          return this.getNodesInternal().reduceRight(function (accum, n, i) {
            return fn.call(_this24, accum, _this24.wrap(n), i);
          }, initialValue);
        }
        return this.getNodesInternal().reduceRight(function (accum, n, i) {
          return fn.call(_this24, i === 1 ? _this24.wrap(accum) : accum, _this24.wrap(n), i);
        });
      }
      return reduceRight;
    }()

    /**
     * Returns a new wrapper with a subset of the nodes of the original wrapper, according to the
     * rules of `Array#slice`.
     *
     * @param {Number} begin
     * @param {Number} end
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'slice',
    value: function () {
      function slice(begin, end) {
        return this.wrap(this.getNodesInternal().slice(begin, end));
      }
      return slice;
    }()

    /**
     * Returns whether or not any of the nodes in the wrapper match the provided selector.
     *
     * @param {EnzymeSelector} selector
     * @returns {Boolean}
     */
  }, {
    key: 'some',
    value: function () {
      function some(selector) {
        if (this[ROOT] === this) {
          throw new Error('ShallowWrapper::some() can not be called on the root');
        }
        var predicate = (0, _selectors.buildPredicate)(selector);
        return this.getNodesInternal().some(predicate);
      }
      return some;
    }()

    /**
     * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.
     *
     * @param {Function} predicate
     * @returns {Boolean}
     */
  }, {
    key: 'someWhere',
    value: function () {
      function someWhere(predicate) {
        var _this25 = this;
        return this.getNodesInternal().some(function (n, i) {
          return predicate.call(_this25, _this25.wrap(n), i);
        });
      }
      return someWhere;
    }()

    /**
     * Returns whether or not all of the nodes in the wrapper match the provided selector.
     *
     * @param {EnzymeSelector} selector
     * @returns {Boolean}
     */
  }, {
    key: 'every',
    value: function () {
      function every(selector) {
        var predicate = (0, _selectors.buildPredicate)(selector);
        return this.getNodesInternal().every(predicate);
      }
      return every;
    }()

    /**
     * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.
     *
     * @param {Function} predicate
     * @returns {Boolean}
     */
  }, {
    key: 'everyWhere',
    value: function () {
      function everyWhere(predicate) {
        var _this26 = this;
        return this.getNodesInternal().every(function (n, i) {
          return predicate.call(_this26, _this26.wrap(n), i);
        });
      }
      return everyWhere;
    }()

    /**
     * Utility method used to create new wrappers with a mapping function that returns an array of
     * nodes in response to a single node wrapper. The returned wrapper is a single wrapper around
     * all of the mapped nodes flattened (and de-duplicated).
     *
     * @param {Function} fn
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'flatMap',
    value: function () {
      function flatMap(fn) {
        var _this27 = this;
        var nodes = this.getNodesInternal().map(function (n, i) {
          return fn.call(_this27, _this27.wrap(n), i);
        });
        var flattened = (0, _arrayPrototype2['default'])(nodes, 1);
        return this.wrap(flattened.filter(Boolean));
      }
      return flatMap;
    }()

    /**
     * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate
     * function. The predicate function will receive the nodes inside a ShallowWrapper as its
     * first argument.
     *
     * @param {Function} predicate
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'findWhere',
    value: function () {
      function findWhere(predicate) {
        var _this28 = this;
        return findWhereUnwrapped(this, function (n) {
          var node = _this28.wrap(n);
          return node.length > 0 && predicate(node);
        });
      }
      return findWhere;
    }()

    /**
     * Returns the node at a given index of the current wrapper.
     *
     * @param index
     * @returns {ReactElement}
     */
  }, {
    key: 'get',
    value: function () {
      function get(index) {
        return this.getElements()[index];
      }
      return get;
    }()

    /**
     * Returns a wrapper around the node at a given index of the current wrapper.
     *
     * @param index
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'at',
    value: function () {
      function at(index) {
        var nodes = this.getNodesInternal();
        if (index < nodes.length) {
          return this.wrap(nodes[index]);
        }
        return this.wrap([]);
      }
      return at;
    }()

    /**
     * Returns a wrapper around the first node of the current wrapper.
     *
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'first',
    value: function () {
      function first() {
        return this.at(0);
      }
      return first;
    }()

    /**
     * Returns a wrapper around the last node of the current wrapper.
     *
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'last',
    value: function () {
      function last() {
        return this.at(this.length - 1);
      }
      return last;
    }()

    /**
     * Delegates to exists()
     *
     * @returns {boolean}
     */
  }, {
    key: 'isEmpty',
    value: function () {
      function isEmpty() {
        // eslint-disable-next-line no-console
        console.warn('Enzyme::Deprecated method isEmpty() called, use exists() instead.');
        return !this.exists();
      }
      return isEmpty;
    }()

    /**
     * Returns true if the current wrapper has nodes. False otherwise.
     * If called with a selector it returns `.find(selector).exists()` instead.
     *
     * @param {EnzymeSelector} selector (optional)
     * @returns {boolean}
     */
  }, {
    key: 'exists',
    value: function () {
      function exists() {
        var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        return arguments.length > 0 ? this.find(selector).exists() : this.length > 0;
      }
      return exists;
    }()

    /**
     * Utility method that throws an error if the current instance has a length other than one.
     * This is primarily used to enforce that certain methods are only run on a wrapper when it is
     * wrapping a single node.
     *
     * @param fn
     * @returns {*}
     */
  }, {
    key: 'single',
    value: function () {
      function single(name, fn) {
        var fnName = typeof name === 'string' ? name : 'unknown';
        var callback = typeof fn === 'function' ? fn : name;
        if (this.length !== 1) {
          throw new Error('Method \u201C' + fnName + '\u201D is meant to be run on 1 node. ' + String(this.length) + ' found instead.');
        }
        return callback.call(this, this.getNodeInternal());
      }
      return single;
    }()

    /**
     * Helpful utility method to create a new wrapper with the same root as the current wrapper, with
     * any nodes passed in as the first parameter automatically wrapped.
     *
     * @param node
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'wrap',
    value: function () {
      function wrap(node) {
        var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[ROOT];
        if (node instanceof ShallowWrapper) {
          return node;
        }
        for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          args[_key3 - 2] = arguments[_key3];
        }
        return new (Function.prototype.bind.apply(ShallowWrapper, [null].concat([node, root], args)))();
      }
      return wrap;
    }()

    /**
     * Returns an HTML-like string of the shallow render for debugging purposes.
     *
     * @param {Object} [options] - Property bag of additional options.
     * @param {boolean} [options.ignoreProps] - if true, props are omitted from the string.
     * @param {boolean} [options.verbose] - if true, arrays and objects to be verbosely printed.
     * @returns {String}
     */
  }, {
    key: 'debug',
    value: function () {
      function debug() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        return (0, _Debug.debugNodes)(this.getNodesInternal(), options);
      }
      return debug;
    }()

    /**
     * Invokes intercepter and returns itself. intercepter is called with itself.
     * This is helpful when debugging nodes in method chains.
     * @param fn
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'tap',
    value: function () {
      function tap(intercepter) {
        intercepter(this);
        return this;
      }
      return tap;
    }()

    /**
     * Primarily useful for HOCs (higher-order components), this method may only be
     * run on a single, non-DOM node, and will return the node, shallow-rendered.
     *
     * @param {Object} options
     * @returns {ShallowWrapper}
     */
  }, {
    key: 'dive',
    value: function () {
      function dive() {
        var _this29 = this;
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);
        var name = 'dive';
        return this.single(name, function (n) {
          if (n && n.nodeType === 'host') {
            throw new TypeError('ShallowWrapper::' + name + '() can not be called on Host Components');
          }
          var el = (0, _getAdapter2['default'])(_this29[OPTIONS]).nodeToElement(n);
          if (!(0, _Utils.isCustomComponentElement)(el, adapter)) {
            throw new TypeError('ShallowWrapper::' + name + '() can only be called on components');
          }
          var childOptions = makeInheritedChildOptions(_this29, options);
          return _this29.wrap(el, null, childOptions);
        });
      }
      return dive;
    }()

    /**
     * Strips out all the not host-nodes from the list of nodes
     *
     * This method is useful if you want to check for the presence of host nodes
     * (actually rendered HTML elements) ignoring the React nodes.
     */
  }, {
    key: 'hostNodes',
    value: function () {
      function hostNodes() {
        return this.filterWhere(function (n) {
          return typeof n.type() === 'string';
        });
      }
      return hostNodes;
    }()
  }]);
  return ShallowWrapper;
}();

/**
 * Updates the context of the primary wrapper when the
 * `wrappingComponent` re-renders.
 */

function updatePrimaryRootContext(wrappingComponent) {
  var adapter = (0, _getAdapter2['default'])(wrappingComponent[OPTIONS]);
  var primaryWrapper = wrappingComponent[PRIMARY_WRAPPER];
  var primaryRenderer = primaryWrapper[RENDERER];
  var primaryNode = primaryRenderer.getNode();
  var _getContextFromWrappi2 = getContextFromWrappingComponent(wrappingComponent, adapter),
    legacyContext = _getContextFromWrappi2.legacyContext,
    providerValues = _getContextFromWrappi2.providerValues;
  var prevProviderValues = primaryWrapper[PROVIDER_VALUES];
  primaryWrapper.setContext((0, _object2['default'])({}, wrappingComponent[PRIMARY_WRAPPER][OPTIONS].context, legacyContext));
  primaryWrapper[PROVIDER_VALUES] = new Map([].concat(_toConsumableArray(prevProviderValues), _toConsumableArray(providerValues)));
  if (typeof adapter.isContextConsumer === 'function' && adapter.isContextConsumer(primaryNode.type)) {
    var Consumer = primaryNode.type;
    // Adapters with an `isContextConsumer` method will definitely have a `getProviderFromConsumer`
    // method.
    var Provider = adapter.getProviderFromConsumer(Consumer);
    var newValue = providerValues.get(Provider);
    var oldValue = prevProviderValues.get(Provider);

    // Use referential comparison like React
    if (newValue !== oldValue) {
      primaryWrapper.rerender();
    }
  }
}

/**
 * A *special* "root" wrapper that represents the component passed as `wrappingComponent`.
 * It is linked to the primary root such that updates to it will update the primary.
 *
 * @class WrappingComponentWrapper
 */

var WrappingComponentWrapper = function (_ShallowWrapper) {
  _inherits(WrappingComponentWrapper, _ShallowWrapper);
  function WrappingComponentWrapper(nodes, root, RootFinder) {
    _classCallCheck(this, WrappingComponentWrapper);
    var _this30 = _possibleConstructorReturn(this, (WrappingComponentWrapper.__proto__ || Object.getPrototypeOf(WrappingComponentWrapper)).call(this, nodes));
    (0, _Utils.privateSet)(_this30, PRIMARY_WRAPPER, root);
    (0, _Utils.privateSet)(_this30, ROOT_FINDER, RootFinder);
    return _this30;
  }

  /**
   * Like rerender() on ShallowWrapper, except it also does a "full render" of
   * itself and updates the primary ShallowWrapper's context.
   */

  _createClass(WrappingComponentWrapper, [{
    key: 'rerender',
    value: function () {
      function rerender() {
        var _get2;
        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        var result = (_get2 = _get(WrappingComponentWrapper.prototype.__proto__ || Object.getPrototypeOf(WrappingComponentWrapper.prototype), 'rerender', this)).call.apply(_get2, [this].concat(args));
        updatePrimaryRootContext(this);
        return result;
      }
      return rerender;
    }()

    /**
     * Like setState() on ShallowWrapper, except it also does a "full render" of
     * itself and updates the primary ShallowWrapper's context.
     */
  }, {
    key: 'setState',
    value: function () {
      function setState() {
        var _get3;
        for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }
        var result = (_get3 = _get(WrappingComponentWrapper.prototype.__proto__ || Object.getPrototypeOf(WrappingComponentWrapper.prototype), 'setState', this)).call.apply(_get3, [this].concat(args));
        updatePrimaryRootContext(this);
        return result;
      }
      return setState;
    }()

    // eslint-disable-next-line class-methods-use-this
  }, {
    key: 'getWrappingComponent',
    value: function () {
      function getWrappingComponent() {
        throw new Error('ShallowWrapper::getWrappingComponent() can only be called on the root');
      }
      return getWrappingComponent;
    }()
  }]);
  return WrappingComponentWrapper;
}(ShallowWrapper);
if (_Utils.ITERATOR_SYMBOL) {
  Object.defineProperty(ShallowWrapper.prototype, _Utils.ITERATOR_SYMBOL, {
    configurable: true,
    value: function () {
      function iterator() {
        var _ref2;
        var iter = this.getNodesInternal()[_Utils.ITERATOR_SYMBOL]();
        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);
        return _ref2 = {}, _defineProperty(_ref2, _Utils.ITERATOR_SYMBOL, function () {
          return this;
        }), _defineProperty(_ref2, 'next', function () {
          function next() {
            var next = iter.next();
            if (next.done) {
              return {
                done: true
              };
            }
            return {
              done: false,
              value: adapter.nodeToElement(next.value)
            };
          }
          return next;
        }()), _ref2;
      }
      return iterator;
    }()
  });
}
function privateWarning(prop, extraMessage) {
  Object.defineProperty(ShallowWrapper.prototype, prop, {
    get: function () {
      function get() {
        throw new Error('\n        Attempted to access ShallowWrapper::' + String(prop) + ', which was previously a private property on\n        Enzyme ShallowWrapper instances, but is no longer and should not be relied upon.\n        ' + String(extraMessage) + '\n      ');
      }
      return get;
    }(),
    enumerable: false,
    configurable: false
  });
}
privateWarning('node', 'Consider using the getElement() method instead.');
privateWarning('nodes', 'Consider using the getElements() method instead.');
privateWarning('renderer', '');
privateWarning('options', '');
privateWarning('complexSelector', '');
exports['default'] = ShallowWrapper;

//# sourceMappingURL=ShallowWrapper.js.map
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfYXJyYXlQcm90b3R5cGUiLCJyZXF1aXJlIiwiX2hhcyIsIl9lbnp5bWVTaGFsbG93RXF1YWwiLCJfVXRpbHMiLCJfZ2V0QWRhcHRlciIsIl9EZWJ1ZyIsIl9SU1RUcmF2ZXJzYWwiLCJfc2VsZWN0b3JzIiwiTk9ERSIsInN5bSIsIk5PREVTIiwiUkVOREVSRVIiLCJVTlJFTkRFUkVEIiwiUk9PVCIsIk9QVElPTlMiLCJTRVRfU1RBVEUiLCJST09UX05PREVTIiwiQ0hJTERfQ09OVEVYVCIsIldSQVBQSU5HX0NPTVBPTkVOVCIsIlBSSU1BUllfV1JBUFBFUiIsIlJPT1RfRklOREVSIiwiUFJPVklERVJfVkFMVUVTIiwiZmluZFdoZXJlVW53cmFwcGVkIiwid3JhcHBlciIsInByZWRpY2F0ZSIsImZpbHRlciIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsInRyZWVGaWx0ZXIiLCJmbGF0TWFwIiwibiIsImdldE5vZGVJbnRlcm5hbCIsImZpbHRlcldoZXJlVW53cmFwcGVkIiwid3JhcCIsImdldE5vZGVzSW50ZXJuYWwiLCJCb29sZWFuIiwidmFsaWRhdGVPcHRpb25zIiwib3B0aW9ucyIsImxpZmVjeWNsZUV4cGVyaW1lbnRhbCIsImRpc2FibGVMaWZlY3ljbGVNZXRob2RzIiwiZW5hYmxlQ29tcG9uZW50RGlkVXBkYXRlT25TZXRTdGF0ZSIsInN1cHBvcnRQcmV2Q29udGV4dEFyZ3VtZW50T2ZDb21wb25lbnREaWRVcGRhdGUiLCJsaWZlY3ljbGVzIiwiRXJyb3IiLCJjb21wb25lbnREaWRVcGRhdGUiLCJvblNldFN0YXRlIiwiVHlwZUVycm9yIiwicHJldkNvbnRleHQiLCJnZXRBZGFwdGVyTGlmZWN5Y2xlcyIsIl9yZWYiLCJfb3B0aW9ucyRsaWZlY3ljbGVzIiwiaGFzTGVnYWN5U2V0U3RhdGVBcmciLCJoYXNMZWdhY3lQcmV2Q29udGV4dEFyZyIsIl9vYmplY3QyIiwib3JpZ2luYWxHRFNGUCIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImhhc1Nob3VsZENvbXBvbmVudFVwZGF0ZUJ1ZyIsInNldFN0YXRlIiwiZ2V0Q2hpbGRDb250ZXh0IiwiY2FsbGVkQnlSZW5kZXJlciIsImdldFJvb3ROb2RlIiwibm9kZSIsIm5vZGVUeXBlIiwicmVuZGVyZWQiLCJnZXRSb290Tm9kZUludGVybmFsIiwibm9kZVBhcmVudHMiLCJwYXJlbnRzT2ZOb2RlIiwicHJpdmF0ZVNldE5vZGVzIiwibm9kZXMiLCJBcnJheSIsImlzQXJyYXkiLCJwcml2YXRlU2V0IiwicHVyZUNvbXBvbmVudFNob3VsZENvbXBvbmVudFVwZGF0ZSIsInByZXZQcm9wcyIsInByb3BzIiwicHJldlN0YXRlIiwic3RhdGUiLCJfZW56eW1lU2hhbGxvd0VxdWFsMiIsImlzUHVyZUNvbXBvbmVudCIsImluc3RhbmNlIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJoaWVyYXJjaHkiLCJyZW5kZXJlciIsIkNvbXBvbmVudCIsInR5cGUiLCJjb21wb25lbnROYW1lIiwiZGlzcGxheU5hbWVPZk5vZGUiLCJfdHlwZW9mIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJjb25zb2xlIiwid2FybiIsIlN0cmluZyIsImNoaWxkQ29udGV4dCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5IiwiY2hlY2tQcm9wVHlwZXMiLCJzcHlPbkdldENoaWxkQ29udGV4dEluaXRpYWxSZW5kZXIiLCJhZGFwdGVyIiwiaXNDdXN0b21Db21wb25lbnRFbGVtZW50IiwicHJvdG90eXBlIiwic3B5TWV0aG9kIiwicHJpdmF0ZVNldENoaWxkQ29udGV4dCIsInJlbmRlcmVkTm9kZSIsImdldENoaWxkQ29udGV4dFNweSIsImxlZ2FjeUNvbnRleHRNb2RlIiwiZ2V0TGFzdFJldHVyblZhbHVlIiwicmVzdG9yZSIsIm5vZGVIaWVyYXJjaHkiLCJjb25jYXQiLCJtb2NrU0NVSWZnRFNGUFJldHVybk5vbk51bGwiLCJfc3B5TWV0aG9kIiwib3JpZ2luYWxTQ1UiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJfbGVuIiwiYXJncyIsIl9rZXkiLCJzQ1VSZXN1bHQiLCJhcHBseSIsIm5leHRTdGF0ZSIsImRlZXBSZW5kZXIiLCJ0YXJnZXQiLCJlbGVtZW50Iiwibm9kZVRvRWxlbWVudCIsImRpdmUiLCJjaGlsZHJlbiIsImkiLCJmb3VuZCIsImF0IiwiZ2V0Q29udGV4dEZyb21XcmFwcGluZ0NvbXBvbmVudCIsInJvb3RGaW5kZXIiLCJsZWdhY3lDb250ZXh0IiwiY29udGV4dCIsInByb3ZpZGVyVmFsdWVzIiwibWFrZVNoYWxsb3dPcHRpb25zIiwicm9vdCIsInBhc3NlZE9wdGlvbnMiLCJtYWtlT3B0aW9ucyIsIl9nZXRBZGFwdGVyMiIsImlzQ3VzdG9tQ29tcG9uZW50Iiwid3JhcHBpbmdDb21wb25lbnQiLCJ3cmFwV2l0aFdyYXBwaW5nQ29tcG9uZW50IiwiX2FkYXB0ZXIkd3JhcFdpdGhXcmFwIiwid3JhcHBlZE5vZGUiLCJSb290RmluZGVyIiwiV3JhcHBpbmdDb21wb25lbnRXcmFwcGVyIiwiX2dldENvbnRleHRGcm9tV3JhcHBpIiwid3JhcHBpbmdDb21wb25lbnRMZWdhY3lDb250ZXh0Iiwid3JhcHBpbmdDb21wb25lbnRQcm92aWRlclZhbHVlcyIsIl9kZWZpbmVQcm9wZXJ0eSIsIm1ha2VJbmhlcml0ZWRDaGlsZE9wdGlvbnMiLCJjaGlsZE9wdGlvbnMiLCJTaGFsbG93V3JhcHBlciIsIl90aGlzIiwiX2NsYXNzQ2FsbENoZWNrIiwiaXNWYWxpZEVsZW1lbnQiLCJjcmVhdGVSZW5kZXJlciIsIm1vZGUiLCJNYXAiLCJyZW5kZXIiLCJnZXROb2RlIiwidXBkYXRlciIsImNhbGxiYWNrIiwiX3RvQ29uc3VtYWJsZUFycmF5IiwiY29tcG9uZW50RGlkTW91bnQiLCJiYXRjaGVkVXBkYXRlcyIsInVwZGF0ZSIsIl90aGlzMiIsInNpbmdsZSIsIl90aGlzMyIsIm1hcCIsInVubW91bnQiLCJfdGhpczQiLCJ3aXRoU2V0U3RhdGVBbGxvd2VkIiwibmV4dENvbnRleHQiLCJzaG91bGRSZW5kZXIiLCJzaG91bGRDb21wb25lbnRVcGRhdGVTcHkiLCJnRFNGUCIsImNsb25lRWxlbWVudCIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwic25hcHNob3QiLCJmcmVlemUiLCJyZXJlbmRlciIsIl90aGlzNSIsInN0YXRlUGF5bG9hZCIsImNhbGwiLCJtYXliZUhhc1VwZGF0ZSIsInNraXBzQ29tcG9uZW50RGlkVXBkYXRlT25OdWxsaXNoIiwiaW52b2tlU2V0U3RhdGVDYWxsYmFjayIsIm5vZGVPck5vZGVzIiwiaXNSZWFjdEVsZW1lbnRBbGlrZSIsIm90aGVyIiwiY29udGFpbnNDaGlsZHJlblN1YkFycmF5Iiwibm9kZUVxdWFsIiwiZWxlbWVudFRvTm9kZSIsInJzdE5vZGUiLCJub2RlTWF0Y2hlcyIsImEiLCJiIiwiX3RoaXM2IiwiZXZlcnkiLCJjb250YWluc01hdGNoaW5nRWxlbWVudCIsIl90aGlzNyIsInNvbWUiLCJfdGhpczgiLCJfdGhpczkiLCJzZWxlY3RvciIsInJlZHVjZVRyZWVzQnlTZWxlY3RvciIsImJ1aWxkUHJlZGljYXRlIiwiaXNFbXB0eVZhbHVlIiwiX3RoaXMxMCIsImdldFRleHRGcm9tTm9kZSIsIl90aGlzMTEiLCJodG1sIiwibG9hZENoZWVyaW9Sb290IiwiZXZlbnQiLCJfdGhpczEyIiwiX2xlbjIiLCJfa2V5MiIsIl9SRU5ERVJFUiIsInNpbXVsYXRlRXZlbnQiLCJlcnJvciIsIl90aGlzMTMiLCJ0aGlzTm9kZSIsInNpbXVsYXRlRXJyb3IiLCJyb290Tm9kZSIsInByb3BzT2ZOb2RlIiwibmFtZSIsIl90aGlzMTQiLCJfc3RhdGUiLCJfdGhpczE1IiwiX2NvbnRleHQiLCJhbGxDaGlsZHJlbiIsImNoaWxkcmVuT2ZOb2RlIiwiaW5kZXgiLCJfdGhpczE2IiwiX3RoaXMxNyIsImFsbFBhcmVudHMiLCJwYXJlbnRzIiwiZ2V0IiwiaXMiLCJtYXRjaGluZ0FuY2VzdG9ycyIsImZpcnN0IiwiZmluZFdoZXJlIiwiX3RoaXMxOCIsInByb3BOYW1lIiwiX3RoaXMxOSIsImhhbmRsZXIiLCJwcm9wIiwicmVzcG9uc2UiLCJfdGhpczIwIiwiUmFuZ2VFcnJvciIsIl9oYXMyIiwicHJvcFZhbHVlIiwid3JhcHBlZCIsInR5cGVPZk5vZGUiLCJjbGFzc05hbWUiLCJpbmRleE9mIiwiaGFzQ2xhc3NOYW1lIiwiZm4iLCJfdGhpczIxIiwiX3RoaXMyMiIsIl90aGlzMjMiLCJpbml0aWFsVmFsdWUiLCJyZWR1Y2UiLCJhY2N1bSIsIl90aGlzMjQiLCJyZWR1Y2VSaWdodCIsImJlZ2luIiwiZW5kIiwic2xpY2UiLCJfdGhpczI1IiwiX3RoaXMyNiIsIl90aGlzMjciLCJmbGF0dGVuZWQiLCJfYXJyYXlQcm90b3R5cGUyIiwiX3RoaXMyOCIsImdldEVsZW1lbnRzIiwiZXhpc3RzIiwiZmluZCIsImZuTmFtZSIsIl9sZW4zIiwiX2tleTMiLCJGdW5jdGlvbiIsImJpbmQiLCJkZWJ1Z05vZGVzIiwiaW50ZXJjZXB0ZXIiLCJfdGhpczI5IiwiZWwiLCJmaWx0ZXJXaGVyZSIsInVwZGF0ZVByaW1hcnlSb290Q29udGV4dCIsInByaW1hcnlXcmFwcGVyIiwicHJpbWFyeVJlbmRlcmVyIiwicHJpbWFyeU5vZGUiLCJfZ2V0Q29udGV4dEZyb21XcmFwcGkyIiwicHJldlByb3ZpZGVyVmFsdWVzIiwic2V0Q29udGV4dCIsImlzQ29udGV4dENvbnN1bWVyIiwiQ29uc3VtZXIiLCJQcm92aWRlciIsImdldFByb3ZpZGVyRnJvbUNvbnN1bWVyIiwibmV3VmFsdWUiLCJvbGRWYWx1ZSIsIl90aGlzMzAiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9fcHJvdG9fXyIsImdldFByb3RvdHlwZU9mIiwiX2dldDIiLCJfbGVuNCIsIl9rZXk0IiwicmVzdWx0IiwiX2dldCIsIl9nZXQzIiwiX2xlbjUiLCJfa2V5NSIsIklURVJBVE9SX1NZTUJPTCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwidmFsdWUiLCJpdGVyYXRvciIsIl9yZWYyIiwiaXRlciIsIm5leHQiLCJkb25lIiwicHJpdmF0ZVdhcm5pbmciLCJleHRyYU1lc3NhZ2UiLCJlbnVtZXJhYmxlIl0sInNvdXJjZXMiOlsiLi4vc3JjL1NoYWxsb3dXcmFwcGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmbGF0IGZyb20gJ2FycmF5LnByb3RvdHlwZS5mbGF0JztcbmltcG9ydCBoYXMgZnJvbSAnaGFzJztcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnZW56eW1lLXNoYWxsb3ctZXF1YWwnO1xuXG5pbXBvcnQge1xuICBub2RlRXF1YWwsXG4gIG5vZGVNYXRjaGVzLFxuICBjb250YWluc0NoaWxkcmVuU3ViQXJyYXksXG4gIHdpdGhTZXRTdGF0ZUFsbG93ZWQsXG4gIHR5cGVPZk5vZGUsXG4gIGlzUmVhY3RFbGVtZW50QWxpa2UsXG4gIGRpc3BsYXlOYW1lT2ZOb2RlLFxuICBpc0N1c3RvbUNvbXBvbmVudCxcbiAgaXNDdXN0b21Db21wb25lbnRFbGVtZW50LFxuICBJVEVSQVRPUl9TWU1CT0wsXG4gIG1ha2VPcHRpb25zLFxuICBzeW0sXG4gIHByaXZhdGVTZXQsXG4gIGNsb25lRWxlbWVudCxcbiAgc3B5TWV0aG9kLFxuICBpc0VtcHR5VmFsdWUsXG4gIGxvYWRDaGVlcmlvUm9vdCxcbn0gZnJvbSAnLi9VdGlscyc7XG5pbXBvcnQgZ2V0QWRhcHRlciBmcm9tICcuL2dldEFkYXB0ZXInO1xuaW1wb3J0IHsgZGVidWdOb2RlcyB9IGZyb20gJy4vRGVidWcnO1xuaW1wb3J0IHtcbiAgcHJvcHNPZk5vZGUsXG4gIGdldFRleHRGcm9tTm9kZSxcbiAgaGFzQ2xhc3NOYW1lLFxuICBjaGlsZHJlbk9mTm9kZSxcbiAgcGFyZW50c09mTm9kZSxcbiAgdHJlZUZpbHRlcixcbn0gZnJvbSAnLi9SU1RUcmF2ZXJzYWwnO1xuaW1wb3J0IHsgYnVpbGRQcmVkaWNhdGUsIHJlZHVjZVRyZWVzQnlTZWxlY3RvciB9IGZyb20gJy4vc2VsZWN0b3JzJztcblxuY29uc3QgTk9ERSA9IHN5bSgnX19ub2RlX18nKTtcbmNvbnN0IE5PREVTID0gc3ltKCdfX25vZGVzX18nKTtcbmNvbnN0IFJFTkRFUkVSID0gc3ltKCdfX3JlbmRlcmVyX18nKTtcbmNvbnN0IFVOUkVOREVSRUQgPSBzeW0oJ19fdW5yZW5kZXJlZF9fJyk7XG5jb25zdCBST09UID0gc3ltKCdfX3Jvb3RfXycpO1xuY29uc3QgT1BUSU9OUyA9IHN5bSgnX19vcHRpb25zX18nKTtcbmNvbnN0IFNFVF9TVEFURSA9IHN5bSgnX19zZXRTdGF0ZV9fJyk7XG5jb25zdCBST09UX05PREVTID0gc3ltKCdfX3Jvb3ROb2Rlc19fJyk7XG5jb25zdCBDSElMRF9DT05URVhUID0gc3ltKCdfX2NoaWxkQ29udGV4dF9fJyk7XG5jb25zdCBXUkFQUElOR19DT01QT05FTlQgPSBzeW0oJ19fd3JhcHBpbmdDb21wb25lbnRfXycpO1xuY29uc3QgUFJJTUFSWV9XUkFQUEVSID0gc3ltKCdfX3ByaW1hcnlXcmFwcGVyX18nKTtcbmNvbnN0IFJPT1RfRklOREVSID0gc3ltKCdfX3Jvb3RGaW5kZXJfXycpO1xuY29uc3QgUFJPVklERVJfVkFMVUVTID0gc3ltKCdfX3Byb3ZpZGVyVmFsdWVzX18nKTtcblxuLyoqXG4gKiBGaW5kcyBhbGwgbm9kZXMgaW4gdGhlIGN1cnJlbnQgd3JhcHBlciBub2RlcycgcmVuZGVyIHRyZWVzIHRoYXQgbWF0Y2ggdGhlIHByb3ZpZGVkIHByZWRpY2F0ZVxuICogZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtTaGFsbG93V3JhcHBlcn0gd3JhcHBlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaWx0ZXJcbiAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAqL1xuZnVuY3Rpb24gZmluZFdoZXJlVW53cmFwcGVkKHdyYXBwZXIsIHByZWRpY2F0ZSwgZmlsdGVyID0gdHJlZUZpbHRlcikge1xuICByZXR1cm4gd3JhcHBlci5mbGF0TWFwKChuKSA9PiBmaWx0ZXIobi5nZXROb2RlSW50ZXJuYWwoKSwgcHJlZGljYXRlKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyB3cmFwcGVyIGluc3RhbmNlIHdpdGggb25seSB0aGUgbm9kZXMgb2YgdGhlIGN1cnJlbnQgd3JhcHBlciBpbnN0YW5jZSB0aGF0IG1hdGNoXG4gKiB0aGUgcHJvdmlkZWQgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7U2hhbGxvd1dyYXBwZXJ9IHdyYXBwZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZVxuICogQHJldHVybnMge1NoYWxsb3dXcmFwcGVyfVxuICovXG5mdW5jdGlvbiBmaWx0ZXJXaGVyZVVud3JhcHBlZCh3cmFwcGVyLCBwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIHdyYXBwZXIud3JhcCh3cmFwcGVyLmdldE5vZGVzSW50ZXJuYWwoKS5maWx0ZXIocHJlZGljYXRlKS5maWx0ZXIoQm9vbGVhbikpO1xufVxuXG4vKipcbiAqIEVuc3VyZSBvcHRpb25zIHBhc3NlZCB0byBTaGFsbG93V3JhcHBlciBhcmUgdmFsaWQuIFRocm93cyBvdGhlcndpc2UuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgbGlmZWN5Y2xlRXhwZXJpbWVudGFsLFxuICAgIGRpc2FibGVMaWZlY3ljbGVNZXRob2RzLFxuICAgIGVuYWJsZUNvbXBvbmVudERpZFVwZGF0ZU9uU2V0U3RhdGUsXG4gICAgc3VwcG9ydFByZXZDb250ZXh0QXJndW1lbnRPZkNvbXBvbmVudERpZFVwZGF0ZSxcbiAgICBsaWZlY3ljbGVzLFxuICB9ID0gb3B0aW9ucztcbiAgaWYgKHR5cGVvZiBsaWZlY3ljbGVFeHBlcmltZW50YWwgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBsaWZlY3ljbGVFeHBlcmltZW50YWwgIT09ICdib29sZWFuJykge1xuICAgIHRocm93IG5ldyBFcnJvcignbGlmZWN5Y2xlRXhwZXJpbWVudGFsIG11c3QgYmUgZWl0aGVyIHRydWUgb3IgZmFsc2UgaWYgcHJvdmlkZWQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGlzYWJsZUxpZmVjeWNsZU1ldGhvZHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkaXNhYmxlTGlmZWN5Y2xlTWV0aG9kcyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaXNhYmxlTGlmZWN5Y2xlTWV0aG9kcyBtdXN0IGJlIGVpdGhlciB0cnVlIG9yIGZhbHNlIGlmIHByb3ZpZGVkJyk7XG4gIH1cblxuICBpZiAoXG4gICAgbGlmZWN5Y2xlRXhwZXJpbWVudGFsICE9IG51bGxcbiAgICAmJiBkaXNhYmxlTGlmZWN5Y2xlTWV0aG9kcyAhPSBudWxsXG4gICAgJiYgbGlmZWN5Y2xlRXhwZXJpbWVudGFsID09PSBkaXNhYmxlTGlmZWN5Y2xlTWV0aG9kc1xuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2xpZmVjeWNsZUV4cGVyaW1lbnRhbCBhbmQgZGlzYWJsZUxpZmVjeWNsZU1ldGhvZHMgY2Fubm90IGJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZScpO1xuICB9XG5cbiAgaWYgKFxuICAgIHR5cGVvZiBlbmFibGVDb21wb25lbnREaWRVcGRhdGVPblNldFN0YXRlICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIGxpZmVjeWNsZXMuY29tcG9uZW50RGlkVXBkYXRlXG4gICAgJiYgbGlmZWN5Y2xlcy5jb21wb25lbnREaWRVcGRhdGUub25TZXRTdGF0ZSAhPT0gZW5hYmxlQ29tcG9uZW50RGlkVXBkYXRlT25TZXRTdGF0ZVxuICApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGUgbGVnYWN5IGVuYWJsZUNvbXBvbmVudERpZFVwZGF0ZU9uU2V0U3RhdGUgb3B0aW9uIHNob3VsZCBiZSBtYXRjaGVkIGJ5IGBsaWZlY3ljbGVzOiB7IGNvbXBvbmVudERpZFVwZGF0ZTogeyBvblNldFN0YXRlOiB0cnVlIH0gfWAsIGZvciBjb21wYXRpYmlsaXR5Jyk7XG4gIH1cblxuICBpZiAoXG4gICAgdHlwZW9mIHN1cHBvcnRQcmV2Q29udGV4dEFyZ3VtZW50T2ZDb21wb25lbnREaWRVcGRhdGUgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgbGlmZWN5Y2xlcy5jb21wb25lbnREaWRVcGRhdGVcbiAgICAmJiBsaWZlY3ljbGVzLmNvbXBvbmVudERpZFVwZGF0ZS5wcmV2Q29udGV4dCAhPT0gc3VwcG9ydFByZXZDb250ZXh0QXJndW1lbnRPZkNvbXBvbmVudERpZFVwZGF0ZVxuICApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0aGUgbGVnYWN5IHN1cHBvcnRQcmV2Q29udGV4dEFyZ3VtZW50T2ZDb21wb25lbnREaWRVcGRhdGUgb3B0aW9uIHNob3VsZCBiZSBtYXRjaGVkIGJ5IGBsaWZlY3ljbGVzOiB7IGNvbXBvbmVudERpZFVwZGF0ZTogeyBwcmV2Q29udGV4dDogdHJ1ZSB9IH1gLCBmb3IgY29tcGF0aWJpbGl0eScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFkYXB0ZXJMaWZlY3ljbGVzKHsgb3B0aW9ucyB9KSB7XG4gIGNvbnN0IHtcbiAgICBsaWZlY3ljbGVzID0ge30sXG4gICAgZW5hYmxlQ29tcG9uZW50RGlkVXBkYXRlT25TZXRTdGF0ZSxcbiAgICBzdXBwb3J0UHJldkNvbnRleHRBcmd1bWVudE9mQ29tcG9uZW50RGlkVXBkYXRlLFxuICB9ID0gb3B0aW9ucztcblxuICBjb25zdCBoYXNMZWdhY3lTZXRTdGF0ZUFyZyA9IHR5cGVvZiBlbmFibGVDb21wb25lbnREaWRVcGRhdGVPblNldFN0YXRlICE9PSAndW5kZWZpbmVkJztcbiAgY29uc3QgaGFzTGVnYWN5UHJldkNvbnRleHRBcmcgPSB0eXBlb2Ygc3VwcG9ydFByZXZDb250ZXh0QXJndW1lbnRPZkNvbXBvbmVudERpZFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIGNvbnN0IGNvbXBvbmVudERpZFVwZGF0ZSA9IGhhc0xlZ2FjeVNldFN0YXRlQXJnIHx8IGhhc0xlZ2FjeVByZXZDb250ZXh0QXJnXG4gICAgPyB7XG4gICAgICAuLi4oaGFzTGVnYWN5U2V0U3RhdGVBcmcgJiYge1xuICAgICAgICBvblNldFN0YXRlOiAhIWVuYWJsZUNvbXBvbmVudERpZFVwZGF0ZU9uU2V0U3RhdGUsXG4gICAgICB9KSxcbiAgICAgIC4uLihoYXNMZWdhY3lQcmV2Q29udGV4dEFyZyAmJiB7XG4gICAgICAgIHByZXZDb250ZXh0OiAhIXN1cHBvcnRQcmV2Q29udGV4dEFyZ3VtZW50T2ZDb21wb25lbnREaWRVcGRhdGUsXG4gICAgICB9KSxcbiAgICB9XG4gICAgOiBudWxsO1xuICBjb25zdCB7IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogb3JpZ2luYWxHRFNGUCB9ID0gbGlmZWN5Y2xlcztcbiAgY29uc3QgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gb3JpZ2luYWxHRFNGUCA/IHtcbiAgICBoYXNTaG91bGRDb21wb25lbnRVcGRhdGVCdWc6ICEhb3JpZ2luYWxHRFNGUC5oYXNTaG91bGRDb21wb25lbnRVcGRhdGVCdWcsXG4gIH0gOiBmYWxzZTtcblxuICByZXR1cm4ge1xuICAgIC4uLmxpZmVjeWNsZXMsXG4gICAgc2V0U3RhdGU6IHtcbiAgICAgIC4uLmxpZmVjeWNsZXMuc2V0U3RhdGUsXG4gICAgfSxcbiAgICBnZXRDaGlsZENvbnRleHQ6IHtcbiAgICAgIGNhbGxlZEJ5UmVuZGVyZXI6IHRydWUsXG4gICAgICAuLi5saWZlY3ljbGVzLmdldENoaWxkQ29udGV4dCxcbiAgICB9LFxuICAgIC4uLihjb21wb25lbnREaWRVcGRhdGUgJiYgeyBjb21wb25lbnREaWRVcGRhdGUgfSksXG4gICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRSb290Tm9kZShub2RlKSB7XG4gIGlmIChub2RlLm5vZGVUeXBlID09PSAnaG9zdCcpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZXR1cm4gbm9kZS5yZW5kZXJlZDtcbn1cblxuZnVuY3Rpb24gZ2V0Um9vdE5vZGVJbnRlcm5hbCh3cmFwcGVyKSB7XG4gIGlmICh3cmFwcGVyW1JPT1RdLmxlbmd0aCAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2V0Um9vdE5vZGVJbnRlcm5hbCh3cmFwcGVyKSBjYW4gb25seSBiZSBjYWxsZWQgd2hlbiB3cmFwcGVyIHdyYXBzIG9uZSBub2RlJyk7XG4gIH1cbiAgaWYgKHdyYXBwZXJbUk9PVF0gIT09IHdyYXBwZXIpIHtcbiAgICByZXR1cm4gd3JhcHBlcltST09UX05PREVTXVswXTtcbiAgfVxuICByZXR1cm4gd3JhcHBlcltST09UXVtOT0RFXTtcbn1cblxuZnVuY3Rpb24gbm9kZVBhcmVudHMod3JhcHBlciwgbm9kZSkge1xuICByZXR1cm4gcGFyZW50c09mTm9kZShub2RlLCBnZXRSb290Tm9kZUludGVybmFsKHdyYXBwZXIpKTtcbn1cblxuZnVuY3Rpb24gcHJpdmF0ZVNldE5vZGVzKHdyYXBwZXIsIG5vZGVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICBwcml2YXRlU2V0KHdyYXBwZXIsIE5PREUsIG5vZGVzKTtcbiAgICBwcml2YXRlU2V0KHdyYXBwZXIsIE5PREVTLCBbbm9kZXNdKTtcbiAgfSBlbHNlIHtcbiAgICBwcml2YXRlU2V0KHdyYXBwZXIsIE5PREUsIG5vZGVzWzBdKTtcbiAgICBwcml2YXRlU2V0KHdyYXBwZXIsIE5PREVTLCBub2Rlcyk7XG4gIH1cbiAgcHJpdmF0ZVNldCh3cmFwcGVyLCAnbGVuZ3RoJywgd3JhcHBlcltOT0RFU10ubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gcHVyZUNvbXBvbmVudFNob3VsZENvbXBvbmVudFVwZGF0ZShwcmV2UHJvcHMsIHByb3BzLCBwcmV2U3RhdGUsIHN0YXRlKSB7XG4gIHJldHVybiAhc2hhbGxvd0VxdWFsKHByZXZQcm9wcywgcHJvcHMpIHx8ICFzaGFsbG93RXF1YWwocHJldlN0YXRlLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGlzUHVyZUNvbXBvbmVudChpbnN0YW5jZSkge1xuICByZXR1cm4gaW5zdGFuY2UgJiYgaW5zdGFuY2UuaXNQdXJlUmVhY3RDb21wb25lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkQ29udGV4dChub2RlLCBoaWVyYXJjaHksIHJlbmRlcmVyKSB7XG4gIGNvbnN0IHsgaW5zdGFuY2UsIHR5cGU6IENvbXBvbmVudCB9ID0gbm9kZTtcbiAgY29uc3QgY29tcG9uZW50TmFtZSA9IGRpc3BsYXlOYW1lT2ZOb2RlKG5vZGUpO1xuICAvLyBXYXJuIGxpa2UgcmVhY3QgaWYgY2hpbGRDb250ZXh0VHlwZXMgaXMgbm90IGRlZmluZWQ6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iLzE0NTRhOGJlMDM3OTRmNWUwYjIzYTdlNzY5NmNiYmJkY2Y4YjBmNWQvcGFja2FnZXMvcmVhY3QtZG9tL3NyYy9zZXJ2ZXIvUmVhY3RQYXJ0aWFsUmVuZGVyZXIuanMjTDYzOS1MNjQ2XG4gIGlmICh0eXBlb2YgQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzICE9PSAnb2JqZWN0Jykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYCR7Y29tcG9uZW50TmFtZX0uZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byB1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuYCxcbiAgICApO1xuICAgIHJldHVybiB7fTtcbiAgfVxuICAvLyBDaGVjayBjaGlsZENvbnRleHRUeXBlcyBsaWtlIHJlYWN0OlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi8xNDU0YThiZTAzNzk0ZjVlMGIyM2E3ZTc2OTZjYmJiZGNmOGIwZjVkL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2VydmVyL1JlYWN0UGFydGlhbFJlbmRlcmVyLmpzI0w2MzAtTDYzN1xuICBjb25zdCBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcbiAgT2JqZWN0LmtleXMoY2hpbGRDb250ZXh0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoIShrZXkgaW4gQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgJHtjb21wb25lbnROYW1lfS5nZXRDaGlsZENvbnRleHQoKToga2V5IFwiJHtrZXl9XCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuYCxcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbiAgaWYgKHR5cGVvZiByZW5kZXJlci5jaGVja1Byb3BUeXBlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlbmRlcmVyLmNoZWNrUHJvcFR5cGVzKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcsIGhpZXJhcmNoeSk7XG4gIH1cbiAgcmV0dXJuIGNoaWxkQ29udGV4dDtcbn1cblxuZnVuY3Rpb24gc3B5T25HZXRDaGlsZENvbnRleHRJbml0aWFsUmVuZGVyKG5vZGVzLCBhZGFwdGVyKSB7XG4gIGlmIChcbiAgICAhaXNDdXN0b21Db21wb25lbnRFbGVtZW50KG5vZGVzLCBhZGFwdGVyKVxuICAgIHx8ICFub2Rlcy50eXBlLnByb3RvdHlwZVxuICAgIHx8IHR5cGVvZiBub2Rlcy50eXBlLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gc3B5TWV0aG9kKG5vZGVzLnR5cGUucHJvdG90eXBlLCAnZ2V0Q2hpbGRDb250ZXh0Jyk7XG59XG5cbmZ1bmN0aW9uIHByaXZhdGVTZXRDaGlsZENvbnRleHQoYWRhcHRlciwgd3JhcHBlciwgaW5zdGFuY2UsIHJlbmRlcmVkTm9kZSwgZ2V0Q2hpbGRDb250ZXh0U3B5KSB7XG4gIGNvbnN0IHJlbmRlcmVyID0gd3JhcHBlcltSRU5ERVJFUl07XG4gIC8vIFdlIG9ubHkgc3VwcG9ydCBwYXJlbnQtYmFzZWQgY29udGV4dC5cbiAgaWYgKGFkYXB0ZXIub3B0aW9ucy5sZWdhY3lDb250ZXh0TW9kZSAhPT0gJ3BhcmVudCcpIHsgcmV0dXJuOyB9XG4gIGlmIChnZXRDaGlsZENvbnRleHRTcHkpIHtcbiAgICBwcml2YXRlU2V0KHdyYXBwZXIsIENISUxEX0NPTlRFWFQsIGdldENoaWxkQ29udGV4dFNweS5nZXRMYXN0UmV0dXJuVmFsdWUoKSk7XG4gICAgZ2V0Q2hpbGRDb250ZXh0U3B5LnJlc3RvcmUoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gSWYgdGhlcmUncyBubyBzcHkgYnV0IGdldENoaWxkQ29udGV4dCBpcyBhIGZ1bmN0aW9uLCB0aGF0IG1lYW5zIG91ciByZW5kZXJlclxuICAgIC8vIGlzIG5vdCBnb2luZyB0byBjYWxsIGl0IGZvciB1cywgc28gd2UgbmVlZCB0byBjYWxsIGl0IG91cnNlbHZlcy5cbiAgICBjb25zdCBub2RlSGllcmFyY2h5ID0gW3dyYXBwZXJbTk9ERV1dLmNvbmNhdChub2RlUGFyZW50cyh3cmFwcGVyLCB3cmFwcGVyW05PREVdKSk7XG4gICAgY29uc3QgY2hpbGRDb250ZXh0ID0gZ2V0Q2hpbGRDb250ZXh0KHJlbmRlcmVkTm9kZSwgbm9kZUhpZXJhcmNoeSwgcmVuZGVyZXIpO1xuICAgIHByaXZhdGVTZXQod3JhcHBlciwgQ0hJTERfQ09OVEVYVCwgY2hpbGRDb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICBwcml2YXRlU2V0KHdyYXBwZXIsIENISUxEX0NPTlRFWFQsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vY2tTQ1VJZmdEU0ZQUmV0dXJuTm9uTnVsbChub2RlLCBzdGF0ZSkge1xuICBjb25zdCB7IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyB9ID0gbm9kZS50eXBlO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gd2UgdHJ5IHRvIGZpeCBhIFJlYWN0IHNoYWxsb3cgcmVuZGVyZXIgYnVnIGhlcmUuXG4gICAgLy8gKGZhY2Vib29rL3JlYWN0IzE0NjA3LCB3aGljaCBoYXMgYmVlbiBmaXhlZCBpbiByZWFjdCAxNi44KTpcbiAgICAvLyB3aGVuIGdEU0ZQIHJldHVybiBkZXJpdmVkIHN0YXRlLCBpdCB3aWxsIHNldCBpbnN0YW5jZSBzdGF0ZSBpbiBzaGFsbG93IHJlbmRlcmVyIGJlZm9yZSBTQ1UsXG4gICAgLy8gdGhpcyB3aWxsIGNhdXNlIGB0aGlzLnN0YXRlYCBpbiBzQ1UgYmUgdGhlIHVwZGF0ZWQgc3RhdGUsIHdoaWNoIGlzIHdyb25nIGJlaGF2aW9yLlxuICAgIC8vIHNvIHdlIGhhdmUgdG8gd3JhcCBzQ1UgdG8gcGFzcyB0aGUgb2xkIHN0YXRlIHRvIG9yaWdpbmFsIHNDVS5cbiAgICBjb25zdCB7IGluc3RhbmNlIH0gPSBub2RlO1xuICAgIGNvbnN0IHsgcmVzdG9yZSB9ID0gc3B5TWV0aG9kKFxuICAgICAgaW5zdGFuY2UsXG4gICAgICAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyxcbiAgICAgIChvcmlnaW5hbFNDVSkgPT4gZnVuY3Rpb24gc2hvdWxkQ29tcG9uZW50VXBkYXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgY29uc3Qgc0NVUmVzdWx0ID0gb3JpZ2luYWxTQ1UuYXBwbHkoaW5zdGFuY2UsIGFyZ3MpO1xuICAgICAgICBjb25zdCBbLCBuZXh0U3RhdGVdID0gYXJncztcbiAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgIHJlc3RvcmUoKTtcbiAgICAgICAgcmV0dXJuIHNDVVJlc3VsdDtcbiAgICAgIH0sXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGRpdmUoKXMgZXZlcnkgY3VzdG9tIGNvbXBvbmVudCBpbiBhIHdyYXBwZXIgdW50aWxcbiAqIHRoZSB0YXJnZXQgY29tcG9uZW50IGlzIGZvdW5kLlxuICpcbiAqIEBwYXJhbSB7U2hhbGxvd1dyYXBwZXJ9IHdyYXBwZXIgQSBTaGFsbG93V3JhcHBlciB0byBzZWFyY2hcbiAqIEBwYXJhbSB7Q29tcG9uZW50VHlwZX0gdGFyZ2V0IEEgcmVhY3QgY3VzdG9tIGNvbXBvbmVudCB0aGF0LCB3aGVuIGZvdW5kLCB3aWxsIGVuZCByZWN1cnNpb25cbiAqIEBwYXJhbSB7QWRhcHRlcn0gYWRhcHRlciBBbiBFbnp5bWUgYWRhcHRlclxuICogQHJldHVybnMge1NoYWxsb3dXcmFwcGVyfHVuZGVmaW5lZH0gQSBTaGFsbG93V3JhcHBlciBmb3IgdGhlIHRhcmdldCwgb3JcbiAqICB1bmRlZmluZWQgaWYgaXQgY2FuJ3QgYmUgZm91bmRcbiAqL1xuZnVuY3Rpb24gZGVlcFJlbmRlcih3cmFwcGVyLCB0YXJnZXQsIGFkYXB0ZXIpIHtcbiAgY29uc3Qgbm9kZSA9IHdyYXBwZXJbTk9ERV07XG4gIGNvbnN0IGVsZW1lbnQgPSBub2RlICYmIGFkYXB0ZXIubm9kZVRvRWxlbWVudChub2RlKTtcbiAgaWYgKHdyYXBwZXIudHlwZSgpID09PSB0YXJnZXQpIHtcbiAgICByZXR1cm4gd3JhcHBlci5kaXZlKCk7XG4gIH1cbiAgaWYgKGVsZW1lbnQgJiYgaXNDdXN0b21Db21wb25lbnRFbGVtZW50KGVsZW1lbnQsIGFkYXB0ZXIpKSB7XG4gICAgcmV0dXJuIGRlZXBSZW5kZXIod3JhcHBlci5kaXZlKCksIHRhcmdldCwgYWRhcHRlcik7XG4gIH1cbiAgY29uc3QgY2hpbGRyZW4gPSB3cmFwcGVyLmNoaWxkcmVuKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBmb3VuZCA9IGRlZXBSZW5kZXIoY2hpbGRyZW4uYXQoaSksIHRhcmdldCwgYWRhcHRlcik7XG4gICAgaWYgKHR5cGVvZiBmb3VuZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBEZWVwLXJlbmRlcnMgdGhlIGB3cmFwcGluZ0NvbXBvbmVudGAgYW5kIHJldHVybnMgdGhlIGNvbnRleHQgdGhhdCBzaG91bGRcbiAqIGJlIGFjY2Vzc2libGUgdG8gdGhlIHByaW1hcnkgd3JhcHBlci5cbiAqXG4gKiBAcGFyYW0ge1dyYXBwaW5nQ29tcG9uZW50V3JhcHBlcn0gd3JhcHBlciBUaGUgYFdyYXBwaW5nQ29tcG9uZW50V3JhcHBlcmAgZm9yIGFcbiAqICBgd3JhcHBpbmdDb21wb25lbnRgXG4gKiBAcGFyYW0ge0FkYXB0ZXJ9IGFkYXB0ZXIgQW4gRW56eW1lIGFkYXB0ZXJcbiAqIEByZXR1cm5zIHtvYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIGFuIG9iamVjdCBvZiBsZWdhY3kgY29udGV4dCB2YWx1ZXMgYW5kIGEgTWFwIG9mXG4gKiAgYGNyZWF0ZUNvbnRleHQoKWAgUHJvdmlkZXIgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRDb250ZXh0RnJvbVdyYXBwaW5nQ29tcG9uZW50KHdyYXBwZXIsIGFkYXB0ZXIpIHtcbiAgY29uc3Qgcm9vdEZpbmRlciA9IGRlZXBSZW5kZXIod3JhcHBlciwgd3JhcHBlcltST09UX0ZJTkRFUl0sIGFkYXB0ZXIpO1xuICBpZiAoIXJvb3RGaW5kZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3cmFwcGluZ0NvbXBvbmVudGAgbXVzdCByZW5kZXIgaXRzIGNoaWxkcmVuIScpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbGVnYWN5Q29udGV4dDogcm9vdEZpbmRlcltPUFRJT05TXS5jb250ZXh0LFxuICAgIHByb3ZpZGVyVmFsdWVzOiByb290RmluZGVyW1BST1ZJREVSX1ZBTFVFU10sXG4gIH07XG59XG5cbi8qKlxuICogTWFrZXMgb3B0aW9ucyBzcGVjaWZpY2FsbHkgZm9yIGBTaGFsbG93V3JhcHBlcmAuIE1vc3Qgb2YgdGhlIGxvZ2ljIGhlcmUgaXMgYXJvdW5kIHJlbmRlcmluZ1xuICogYSBgd3JhcHBpbmdDb21wb25lbnRgIChpZiBvbmUgd2FzIHByb3ZpZGVkKSBhbmQgYWRkaW5nIHRoZSBjaGlsZCBjb250ZXh0IG9mIHRoYXQgY29tcG9uZW50XG4gKiB0byBgb3B0aW9ucy5jb250ZXh0YC5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbm9kZXMgdGhlIG5vZGVzIHBhc3NlZCB0byBgU2hhbGxvd1dyYXBwZXJgXG4gKiBAcGFyYW0ge1NoYWxsb3dXcmFwcGVyfSByb290IHRoaXMgYFNoYWxsb3dXcmFwcGVyYCdzIHBhcmVudC4gSWYgdGhpcyBpcyBwYXNzZWQsIG9wdGlvbnMgYXJlXG4gKiAgbm90IHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHsqfSBwYXNzZWRPcHRpb25zIHRoZSBvcHRpb25zIHBhc3NlZCB0byBgU2hhbGxvd1dyYXBwZXJgLlxuICogQHBhcmFtIHsqfSB3cmFwcGVyIHRoZSBgU2hhbGxvd1dyYXBwZXJgIGl0c2VsZlxuICogQHJldHVybnMge09iamVjdH0gdGhlIGRlY29yYXRlZCBhbmQgdHJhbnNmb3JtZWQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBtYWtlU2hhbGxvd09wdGlvbnMobm9kZXMsIHJvb3QsIHBhc3NlZE9wdGlvbnMsIHdyYXBwZXIpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IG1ha2VPcHRpb25zKHBhc3NlZE9wdGlvbnMpO1xuICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcihwYXNzZWRPcHRpb25zKTtcbiAgcHJpdmF0ZVNldChvcHRpb25zLCBQUk9WSURFUl9WQUxVRVMsIHBhc3NlZE9wdGlvbnNbUFJPVklERVJfVkFMVUVTXSk7XG4gIGlmIChyb290IHx8ICFpc0N1c3RvbUNvbXBvbmVudChvcHRpb25zLndyYXBwaW5nQ29tcG9uZW50LCBhZGFwdGVyKSkge1xuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGlmICh0eXBlb2YgYWRhcHRlci53cmFwV2l0aFdyYXBwaW5nQ29tcG9uZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigneW91ciBhZGFwdGVyIGRvZXMgbm90IHN1cHBvcnQgYHdyYXBwaW5nQ29tcG9uZW50YC4gVHJ5IHVwZ3JhZGluZyBpdCEnKTtcbiAgfVxuICBjb25zdCB7IG5vZGU6IHdyYXBwZWROb2RlLCBSb290RmluZGVyIH0gPSBhZGFwdGVyLndyYXBXaXRoV3JhcHBpbmdDb21wb25lbnQobm9kZXMsIG9wdGlvbnMpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgY29uc3Qgd3JhcHBpbmdDb21wb25lbnQgPSBuZXcgV3JhcHBpbmdDb21wb25lbnRXcmFwcGVyKHdyYXBwZWROb2RlLCB3cmFwcGVyLCBSb290RmluZGVyKTtcbiAgY29uc3Qge1xuICAgIGxlZ2FjeUNvbnRleHQ6IHdyYXBwaW5nQ29tcG9uZW50TGVnYWN5Q29udGV4dCxcbiAgICBwcm92aWRlclZhbHVlczogd3JhcHBpbmdDb21wb25lbnRQcm92aWRlclZhbHVlcyxcbiAgfSA9IGdldENvbnRleHRGcm9tV3JhcHBpbmdDb21wb25lbnQod3JhcHBpbmdDb21wb25lbnQsIGFkYXB0ZXIpO1xuICBwcml2YXRlU2V0KHdyYXBwZXIsIFdSQVBQSU5HX0NPTVBPTkVOVCwgd3JhcHBpbmdDb21wb25lbnQpO1xuICByZXR1cm4ge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgY29udGV4dDoge1xuICAgICAgLi4ub3B0aW9ucy5jb250ZXh0LFxuICAgICAgLi4ud3JhcHBpbmdDb21wb25lbnRMZWdhY3lDb250ZXh0LFxuICAgIH0sXG4gICAgW1BST1ZJREVSX1ZBTFVFU106IHdyYXBwaW5nQ29tcG9uZW50UHJvdmlkZXJWYWx1ZXMsXG4gIH07XG59XG5cblxuZnVuY3Rpb24gbWFrZUluaGVyaXRlZENoaWxkT3B0aW9ucyh3cmFwcGVyLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgY2hpbGRPcHRpb25zID0ge1xuICAgIC4uLndyYXBwZXJbT1BUSU9OU10sXG4gICAgLi4ub3B0aW9ucyxcbiAgICBjb250ZXh0OiBvcHRpb25zLmNvbnRleHQgfHwge1xuICAgICAgLi4ud3JhcHBlcltPUFRJT05TXS5jb250ZXh0LFxuICAgICAgLi4ud3JhcHBlcltST09UXVtDSElMRF9DT05URVhUXSxcbiAgICB9LFxuICB9O1xuICBwcml2YXRlU2V0KGNoaWxkT3B0aW9ucywgUFJPVklERVJfVkFMVUVTLCB3cmFwcGVyW1JPT1RdW1BST1ZJREVSX1ZBTFVFU10pO1xuICByZXR1cm4gY2hpbGRPcHRpb25zO1xufVxuXG5cbi8qKlxuICogQGNsYXNzIFNoYWxsb3dXcmFwcGVyXG4gKi9cbmNsYXNzIFNoYWxsb3dXcmFwcGVyIHtcbiAgY29uc3RydWN0b3Iobm9kZXMsIHJvb3QsIHBhc3NlZE9wdGlvbnMgPSB7fSkge1xuICAgIHZhbGlkYXRlT3B0aW9ucyhwYXNzZWRPcHRpb25zKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSBtYWtlU2hhbGxvd09wdGlvbnMobm9kZXMsIHJvb3QsIHBhc3NlZE9wdGlvbnMsIHRoaXMpO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSBnZXRBZGFwdGVyKG9wdGlvbnMpO1xuICAgIGNvbnN0IGxpZmVjeWNsZXMgPSBnZXRBZGFwdGVyTGlmZWN5Y2xlcyhhZGFwdGVyKTtcblxuICAgIC8vIG1vdW50aW5nIGEgU2hhbGxvd1JlbmRlciBjb21wb25lbnRcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgIGlmICghYWRhcHRlci5pc1ZhbGlkRWxlbWVudChub2RlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2hhbGxvd1dyYXBwZXIgY2FuIG9ubHkgd3JhcCB2YWxpZCBlbGVtZW50cycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBnZXRDaGlsZENvbnRleHRTcHkgPSBsaWZlY3ljbGVzLmdldENoaWxkQ29udGV4dC5jYWxsZWRCeVJlbmRlcmVyXG4gICAgICAgID8gc3B5T25HZXRDaGlsZENvbnRleHRJbml0aWFsUmVuZGVyKG5vZGVzLCBhZGFwdGVyKVxuICAgICAgICA6IG51bGw7XG4gICAgICBwcml2YXRlU2V0KHRoaXMsIFJPT1QsIHRoaXMpO1xuICAgICAgcHJpdmF0ZVNldCh0aGlzLCBVTlJFTkRFUkVELCBub2Rlcyk7XG4gICAgICBjb25zdCByZW5kZXJlciA9IGFkYXB0ZXIuY3JlYXRlUmVuZGVyZXIoeyBtb2RlOiAnc2hhbGxvdycsIC4uLm9wdGlvbnMgfSk7XG4gICAgICBwcml2YXRlU2V0KHRoaXMsIFJFTkRFUkVSLCByZW5kZXJlcik7XG4gICAgICBjb25zdCBwcm92aWRlclZhbHVlcyA9IG5ldyBNYXAob3B0aW9uc1tQUk9WSURFUl9WQUxVRVNdIHx8IFtdKTtcbiAgICAgIHRoaXNbUkVOREVSRVJdLnJlbmRlcihub2Rlcywgb3B0aW9ucy5jb250ZXh0LCB7IHByb3ZpZGVyVmFsdWVzIH0pO1xuICAgICAgY29uc3QgcmVuZGVyZWROb2RlID0gdGhpc1tSRU5ERVJFUl0uZ2V0Tm9kZSgpO1xuICAgICAgcHJpdmF0ZVNldE5vZGVzKHRoaXMsIGdldFJvb3ROb2RlKHJlbmRlcmVkTm9kZSkpO1xuICAgICAgcHJpdmF0ZVNldCh0aGlzLCBPUFRJT05TLCBvcHRpb25zKTtcbiAgICAgIHByaXZhdGVTZXQodGhpcywgUFJPVklERVJfVkFMVUVTLCBwcm92aWRlclZhbHVlcyk7XG5cbiAgICAgIGNvbnN0IHsgaW5zdGFuY2UgfSA9IHJlbmRlcmVkTm9kZTtcbiAgICAgIGlmIChpbnN0YW5jZSAmJiAhb3B0aW9ucy5kaXNhYmxlTGlmZWN5Y2xlTWV0aG9kcykge1xuICAgICAgICAvLyBFbnN1cmUgdG8gY2FsbCBjb21wb25lbnREaWRVcGRhdGUgd2hlbiBpbnN0YW5jZS5zZXRTdGF0ZSBpcyBjYWxsZWRcbiAgICAgICAgaWYgKGxpZmVjeWNsZXMuY29tcG9uZW50RGlkVXBkYXRlLm9uU2V0U3RhdGUgJiYgIWluc3RhbmNlW1NFVF9TVEFURV0pIHtcbiAgICAgICAgICBwcml2YXRlU2V0KGluc3RhbmNlLCBTRVRfU1RBVEUsIGluc3RhbmNlLnNldFN0YXRlKTtcbiAgICAgICAgICBpbnN0YW5jZS5zZXRTdGF0ZSA9ICh1cGRhdGVyLCBjYWxsYmFjayA9IHVuZGVmaW5lZCkgPT4gdGhpcy5zZXRTdGF0ZShcbiAgICAgICAgICAgIC4uLihjYWxsYmFjayA9PSBudWxsID8gW3VwZGF0ZXJdIDogW3VwZGF0ZXIsIGNhbGxiYWNrXSksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzW1JFTkRFUkVSXS5iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHByaXZhdGVTZXRDaGlsZENvbnRleHQoYWRhcHRlciwgdGhpcywgaW5zdGFuY2UsIHJlbmRlcmVkTm9kZSwgZ2V0Q2hpbGRDb250ZXh0U3B5KTtcbiAgICAgIH1cbiAgICAvLyBjcmVhdGluZyBhIGNoaWxkIGNvbXBvbmVudCB0aHJvdWdoIGVuenltZSdzIFNoYWxsb3dXcmFwcGVyIEFQSXMuXG4gICAgfSBlbHNlIHtcbiAgICAgIHByaXZhdGVTZXQodGhpcywgUk9PVCwgcm9vdCk7XG4gICAgICBwcml2YXRlU2V0KHRoaXMsIFVOUkVOREVSRUQsIG51bGwpO1xuICAgICAgcHJpdmF0ZVNldCh0aGlzLCBSRU5ERVJFUiwgcm9vdFtSRU5ERVJFUl0pO1xuICAgICAgcHJpdmF0ZVNldE5vZGVzKHRoaXMsIG5vZGVzKTtcbiAgICAgIHByaXZhdGVTZXQodGhpcywgT1BUSU9OUywgcm9vdFtPUFRJT05TXSk7XG4gICAgICBwcml2YXRlU2V0KHRoaXMsIFJPT1RfTk9ERVMsIHJvb3RbTk9ERVNdKTtcbiAgICAgIHByaXZhdGVTZXQodGhpcywgUFJPVklERVJfVkFMVUVTLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcm9vdCB3cmFwcGVyXG4gICAqXG4gICAqIEByZXR1cm4ge1NoYWxsb3dXcmFwcGVyfVxuICAgKi9cbiAgcm9vdCgpIHtcbiAgICByZXR1cm4gdGhpc1tST09UXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3cmFwcGVkIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBnZXROb2RlSW50ZXJuYWwoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWxsb3dXcmFwcGVyOjpnZXROb2RlKCkgY2FuIG9ubHkgYmUgY2FsbGVkIHdoZW4gd3JhcHBpbmcgb25lIG5vZGUnKTtcbiAgICB9XG4gICAgaWYgKHRoaXNbUk9PVF0gPT09IHRoaXMpIHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzW05PREVdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRoZSB3cmFwcGVkIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PFJlYWN0Q29tcG9uZW50Pn1cbiAgICovXG4gIGdldE5vZGVzSW50ZXJuYWwoKSB7XG4gICAgaWYgKHRoaXNbUk9PVF0gPT09IHRoaXMgJiYgdGhpcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzW05PREVTXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3cmFwcGVkIFJlYWN0RWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RFbGVtZW50fVxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ2dldEVsZW1lbnQnLCAobikgPT4gZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKS5ub2RlVG9FbGVtZW50KG4pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB3cmFwcGVkIFJlYWN0RWxlbWVudHMuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PFJlYWN0RWxlbWVudD59XG4gICAqL1xuICBnZXRFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROb2Rlc0ludGVybmFsKCkubWFwKChuKSA9PiBnZXRBZGFwdGVyKHRoaXNbT1BUSU9OU10pLm5vZGVUb0VsZW1lbnQobikpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgZ2V0Tm9kZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWxsb3dXcmFwcGVyOjpnZXROb2RlKCkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gVXNlIFNoYWxsb3dXcmFwcGVyOjpnZXRFbGVtZW50KCkgaW5zdGVhZCcpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgZ2V0Tm9kZXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaGFsbG93V3JhcHBlcjo6Z2V0Tm9kZXMoKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBVc2UgU2hhbGxvd1dyYXBwZXI6OmdldEVsZW1lbnRzKCkgaW5zdGVhZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGluc3RhbmNlIG9mIHRoZSBjb21wb25lbnQgYmVpbmcgcmVuZGVyZWQgYXMgdGhlIHJvb3Qgbm9kZSBwYXNzZWQgaW50byBgc2hhbGxvdygpYC5cbiAgICpcbiAgICogTk9URTogY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGEgd3JhcHBlciBpbnN0YW5jZSB0aGF0IGlzIGFsc28gdGhlIHJvb3QgaW5zdGFuY2UuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqIGBgYFxuICAgKiBjb25zdCB3cmFwcGVyID0gc2hhbGxvdyg8TXlDb21wb25lbnQgLz4pO1xuICAgKiBjb25zdCBpbnN0ID0gd3JhcHBlci5pbnN0YW5jZSgpO1xuICAgKiBleHBlY3QoaW5zdCkudG8uYmUuaW5zdGFuY2VPZihNeUNvbXBvbmVudCk7XG4gICAqIGBgYFxuICAgKiBAcmV0dXJucyB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBpbnN0YW5jZSgpIHtcbiAgICBpZiAodGhpc1tST09UXSAhPT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFsbG93V3JhcHBlcjo6aW5zdGFuY2UoKSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhlIHJvb3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbUkVOREVSRVJdLmdldE5vZGUoKS5pbnN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBhIGB3cmFwcGluZ0NvbXBvbmVudGAgd2FzIHBhc3NlZCBpbiBgb3B0aW9uc2AsIHRoaXMgbWV0aG9kcyByZXR1cm5zIGEgYFNoYWxsb3dXcmFwcGVyYFxuICAgKiBhcm91bmQgdGhlIHJlbmRlcmVkIGB3cmFwcGluZ0NvbXBvbmVudGAuIFRoaXMgYFNoYWxsb3dXcmFwcGVyYCBjYW4gYmUgdXNlZCB0byB1cGRhdGUgdGhlXG4gICAqIGB3cmFwcGluZ0NvbXBvbmVudGAncyBwcm9wcywgc3RhdGUsIGV0Yy5cbiAgICpcbiAgICogQHJldHVybnMgU2hhbGxvd1dyYXBwZXJcbiAgICovXG4gIGdldFdyYXBwaW5nQ29tcG9uZW50KCkge1xuICAgIGlmICh0aGlzW1JPT1RdICE9PSB0aGlzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWxsb3dXcmFwcGVyOjpnZXRXcmFwcGluZ0NvbXBvbmVudCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB0aGUgcm9vdCcpO1xuICAgIH1cbiAgICBpZiAoIXRoaXNbT1BUSU9OU10ud3JhcHBpbmdDb21wb25lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhbGxvd1dyYXBwZXI6OmdldFdyYXBwaW5nQ29tcG9uZW50KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGEgd3JhcHBlciB0aGF0IHdhcyBvcmlnaW5hbGx5IHBhc3NlZCBhIGB3cmFwcGluZ0NvbXBvbmVudGAgb3B0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzW1dSQVBQSU5HX0NPTVBPTkVOVF07XG4gIH1cblxuICAvKipcbiAgICogRm9yY2VzIGEgcmUtcmVuZGVyLiBVc2VmdWwgdG8gcnVuIGJlZm9yZSBjaGVja2luZyB0aGUgcmVuZGVyIG91dHB1dCBpZiBzb21ldGhpbmcgZXh0ZXJuYWxcbiAgICogbWF5IGJlIHVwZGF0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50IHNvbWV3aGVyZS5cbiAgICpcbiAgICogTk9URTogY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGEgd3JhcHBlciBpbnN0YW5jZSB0aGF0IGlzIGFsc28gdGhlIHJvb3QgaW5zdGFuY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpc1tST09UXSAhPT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFsbG93V3JhcHBlcjo6dXBkYXRlKCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoZSByb290Jyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFsbG93V3JhcHBlcjo6dXBkYXRlKCkgY2FuIG9ubHkgYmUgY2FsbGVkIHdoZW4gd3JhcHBpbmcgb25lIG5vZGUnKTtcbiAgICB9XG4gICAgcHJpdmF0ZVNldE5vZGVzKHRoaXMsIGdldFJvb3ROb2RlKHRoaXNbUkVOREVSRVJdLmdldE5vZGUoKSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRoYXQgdW5tb3VudHMgdGhlIGNvbXBvbmVudC4gVGhpcyBjYW4gYmUgdXNlZCB0byBzaW11bGF0ZSBhIGNvbXBvbmVudCBnb2luZyB0aHJvdWdoXG4gICAqIGFuZCB1bm1vdW50L21vdW50IGxpZmVjeWNsZS5cbiAgICogQHJldHVybnMge1NoYWxsb3dXcmFwcGVyfVxuICAgKi9cbiAgdW5tb3VudCgpIHtcbiAgICB0aGlzW1JFTkRFUkVSXS51bm1vdW50KCk7XG4gICAgaWYgKHRoaXNbUk9PVF1bV1JBUFBJTkdfQ09NUE9ORU5UXSkge1xuICAgICAgdGhpc1tST09UXVtXUkFQUElOR19DT01QT05FTlRdLnVubW91bnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgaXMgZm9yIHJlLXJlbmRlciB3aXRoIG5ldyBwcm9wcyBhbmQgY29udGV4dC5cbiAgICogVGhpcyBjYWxscyBjb21wb25lbnREaWRVcGRhdGUgbWV0aG9kIGlmIGRpc2FibGVMaWZlY3ljbGVNZXRob2RzIGlzIG5vdCBlbmFibGVkLlxuICAgKlxuICAgKiBOT1RFOiBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB3cmFwcGVyIGluc3RhbmNlIHRoYXQgaXMgYWxzbyB0aGUgcm9vdCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIHJlcmVuZGVyKHByb3BzLCBjb250ZXh0KSB7XG4gICAgY29uc3QgYWRhcHRlciA9IGdldEFkYXB0ZXIodGhpc1tPUFRJT05TXSk7XG4gICAgdGhpcy5zaW5nbGUoJ3JlcmVuZGVyJywgKCkgPT4ge1xuICAgICAgd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiB7XG4gICAgICAgIC8vIE5PVEUobG1yKTogSW4gcmVhY3QgMTYsIGluc3RhbmNlcyB3aWxsIGJlIG51bGwgZm9yIFNGQ3MsIGJ1dFxuICAgICAgICAvLyByZXJlbmRlcmluZyB3aXRoIHByb3BzL2NvbnRleHQgaXMgc3RpbGwgYSB2YWxpZCB0aGluZyB0byBkby4gSW5cbiAgICAgICAgLy8gdGhpcyBjYXNlLCBzdGF0ZSB3aWxsIGJlIHVuZGVmaW5lZCwgYnV0IHByb3BzL2NvbnRleHQgd2lsbCBleGlzdC5cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXNbUkVOREVSRVJdLmdldE5vZGUoKTtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBub2RlLmluc3RhbmNlIHx8IHt9O1xuICAgICAgICBjb25zdCB0eXBlID0gbm9kZS50eXBlIHx8IHt9O1xuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSBpbnN0YW5jZTtcbiAgICAgICAgY29uc3QgcHJldlByb3BzID0gaW5zdGFuY2UucHJvcHMgfHwgdGhpc1tVTlJFTkRFUkVEXS5wcm9wcztcbiAgICAgICAgY29uc3QgcHJldkNvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0IHx8IHRoaXNbT1BUSU9OU10uY29udGV4dDtcbiAgICAgICAgY29uc3QgbmV4dENvbnRleHQgPSBjb250ZXh0IHx8IHByZXZDb250ZXh0O1xuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgIHRoaXNbT1BUSU9OU10gPSB7IC4uLnRoaXNbT1BUSU9OU10sIGNvbnRleHQ6IG5leHRDb250ZXh0IH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tSRU5ERVJFUl0uYmF0Y2hlZFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgIC8vIFdoZW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2Ugd2Ugc2hvdWxkbid0IGNhbGwgY29tcG9uZW50RGlkVXBkYXRlLlxuICAgICAgICAgIC8vIHNvIHdlIHNweSBzaG91bGRDb21wb25lbnRVcGRhdGUgdG8gZ2V0IHRoZSByZXN1bHQuXG4gICAgICAgICAgY29uc3QgbGlmZWN5Y2xlcyA9IGdldEFkYXB0ZXJMaWZlY3ljbGVzKGFkYXB0ZXIpO1xuICAgICAgICAgIGxldCBzaG91bGRSZW5kZXIgPSB0cnVlO1xuICAgICAgICAgIGxldCBzaG91bGRDb21wb25lbnRVcGRhdGVTcHk7XG4gICAgICAgICAgbGV0IGdldENoaWxkQ29udGV4dFNweTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhdGhpc1tPUFRJT05TXS5kaXNhYmxlTGlmZWN5Y2xlTWV0aG9kc1xuICAgICAgICAgICAgJiYgaW5zdGFuY2VcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiBnRFNGUCB9ID0gbGlmZWN5Y2xlcztcbiAgICAgICAgICAgICAgaWYgKGdEU0ZQICYmIGdEU0ZQLmhhc1Nob3VsZENvbXBvbmVudFVwZGF0ZUJ1Zykge1xuICAgICAgICAgICAgICAgIG1vY2tTQ1VJZmdEU0ZQUmV0dXJuTm9uTnVsbChub2RlLCBzdGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2hvdWxkQ29tcG9uZW50VXBkYXRlU3B5ID0gc3B5TWV0aG9kKGluc3RhbmNlLCAnc2hvdWxkQ29tcG9uZW50VXBkYXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGxpZmVjeWNsZXMuZ2V0Q2hpbGRDb250ZXh0LmNhbGxlZEJ5UmVuZGVyZXJcbiAgICAgICAgICAgICAgJiYgdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGdldENoaWxkQ29udGV4dFNweSA9IHNweU1ldGhvZChpbnN0YW5jZSwgJ2dldENoaWxkQ29udGV4dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNob3VsZENvbXBvbmVudFVwZGF0ZVNweSAmJiBpc1B1cmVDb21wb25lbnQoaW5zdGFuY2UpKSB7XG4gICAgICAgICAgICBzaG91bGRSZW5kZXIgPSBwdXJlQ29tcG9uZW50U2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvcHMpIHRoaXNbVU5SRU5ERVJFRF0gPSBjbG9uZUVsZW1lbnQoYWRhcHRlciwgdGhpc1tVTlJFTkRFUkVEXSwgcHJvcHMpO1xuICAgICAgICAgIHRoaXNbUkVOREVSRVJdLnJlbmRlcih0aGlzW1VOUkVOREVSRURdLCBuZXh0Q29udGV4dCwge1xuICAgICAgICAgICAgcHJvdmlkZXJWYWx1ZXM6IHRoaXNbUFJPVklERVJfVkFMVUVTXSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoc2hvdWxkQ29tcG9uZW50VXBkYXRlU3B5KSB7XG4gICAgICAgICAgICBzaG91bGRSZW5kZXIgPSBzaG91bGRDb21wb25lbnRVcGRhdGVTcHkuZ2V0TGFzdFJldHVyblZhbHVlKCk7XG4gICAgICAgICAgICBzaG91bGRDb21wb25lbnRVcGRhdGVTcHkucmVzdG9yZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBzaG91bGRSZW5kZXJcbiAgICAgICAgICAgICYmICF0aGlzW09QVElPTlNdLmRpc2FibGVMaWZlY3ljbGVNZXRob2RzXG4gICAgICAgICAgICAmJiBpbnN0YW5jZVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJpdmF0ZVNldENoaWxkQ29udGV4dChhZGFwdGVyLCB0aGlzLCBpbnN0YW5jZSwgbm9kZSwgZ2V0Q2hpbGRDb250ZXh0U3B5KTtcbiAgICAgICAgICAgIGlmIChsaWZlY3ljbGVzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKSB7XG4gICAgICAgICAgICAgIGxldCBzbmFwc2hvdDtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHNuYXBzaG90ID0gaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocHJldlByb3BzLCBzdGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGxpZmVjeWNsZXMuY29tcG9uZW50RGlkVXBkYXRlXG4gICAgICAgICAgICAgICAgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICYmIChcbiAgICAgICAgICAgICAgICAgICFzdGF0ZVxuICAgICAgICAgICAgICAgICAgfHwgc2hhbGxvd0VxdWFsKHN0YXRlLCB0aGlzLmluc3RhbmNlKCkuc3RhdGUpXG4gICAgICAgICAgICAgICAgICB8fCB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHN0YXRlLCBzbmFwc2hvdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgIGxpZmVjeWNsZXMuY29tcG9uZW50RGlkVXBkYXRlXG4gICAgICAgICAgICAgICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAobGlmZWN5Y2xlcy5jb21wb25lbnREaWRVcGRhdGUucHJldkNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBzdGF0ZSwgcHJldkNvbnRleHQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZSB8fCBzaGFsbG93RXF1YWwodGhpcy5pbnN0YW5jZSgpLnN0YXRlLCBzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBzdGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiBpdCBkb2Vzbid0IG5lZWQgdG8gcmVyZW5kZXIsIHVwZGF0ZSBvbmx5IGl0cyBwcm9wcy5cbiAgICAgICAgICB9IGVsc2UgaWYgKCFzaGFsbG93RXF1YWwocHJvcHMsIGluc3RhbmNlLnByb3BzKSkge1xuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSAoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHsgLi4uaW5zdGFuY2UucHJvcHMsIC4uLnByb3BzIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIHRoYXQgc2V0cyB0aGUgcHJvcHMgb2YgdGhlIHJvb3QgY29tcG9uZW50LCBhbmQgcmUtcmVuZGVycy4gVXNlZnVsIGZvciB3aGVuIHlvdSBhcmVcbiAgICogd2FudGluZyB0byB0ZXN0IGhvdyB0aGUgY29tcG9uZW50IGJlaGF2ZXMgb3ZlciB0aW1lIHdpdGggY2hhbmdpbmcgcHJvcHMuIENhbGxpbmcgdGhpcywgZm9yXG4gICAqIGluc3RhbmNlLCB3aWxsIGNhbGwgdGhlIGBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzYCBsaWZlY3ljbGUgbWV0aG9kLlxuICAgKlxuICAgKiBTaW1pbGFyIHRvIGBzZXRTdGF0ZWAsIHRoaXMgbWV0aG9kIGFjY2VwdHMgYSBwcm9wcyBvYmplY3QgYW5kIHdpbGwgbWVyZ2UgaXQgaW4gd2l0aCB0aGUgYWxyZWFkeVxuICAgKiBleGlzdGluZyBwcm9wcy5cbiAgICpcbiAgICogTk9URTogY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGEgd3JhcHBlciBpbnN0YW5jZSB0aGF0IGlzIGFsc28gdGhlIHJvb3QgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBvYmplY3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBjYWxsYmFjayBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBzZXRQcm9wcyhwcm9wcywgY2FsbGJhY2sgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpc1tST09UXSAhPT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFsbG93V3JhcHBlcjo6c2V0UHJvcHMoKSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhlIHJvb3QnKTtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhY3RXcmFwcGVyOjpzZXRQcm9wcygpIGV4cGVjdHMgYSBmdW5jdGlvbiBhcyBpdHMgc2Vjb25kIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIHRoaXMucmVyZW5kZXIocHJvcHMpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgdG8gaW52b2tlIGBzZXRTdGF0ZWAgb24gdGhlIHJvb3QgY29tcG9uZW50IGluc3RhbmNlIHNpbWlsYXIgdG8gaG93IHlvdSBtaWdodCBpbiB0aGVcbiAgICogZGVmaW5pdGlvbiBvZiB0aGUgY29tcG9uZW50LCBhbmQgcmUtcmVuZGVycy4gIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCBmb3IgdGVzdGluZyB5b3VyIGNvbXBvbmVudFxuICAgKiBpbiBoYXJkIHRvIGFjaGlldmUgc3RhdGVzLCBob3dldmVyIHNob3VsZCBiZSB1c2VkIHNwYXJpbmdseS4gSWYgcG9zc2libGUsIHlvdSBzaG91bGQgdXRpbGl6ZVxuICAgKiB5b3VyIGNvbXBvbmVudCdzIGV4dGVybmFsIEFQSSBpbiBvcmRlciB0byBnZXQgaXQgaW50byB3aGF0ZXZlciBzdGF0ZSB5b3Ugd2FudCB0byB0ZXN0LCBpbiBvcmRlclxuICAgKiB0byBiZSBhcyBhY2N1cmF0ZSBvZiBhIHRlc3QgYXMgcG9zc2libGUuIFRoaXMgaXMgbm90IGFsd2F5cyBwcmFjdGljYWwsIGhvd2V2ZXIuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgaW5zdGFuY2UgdGhhdCBpcyBhbHNvIHRoZSByb290IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgdG8gbWVyZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBjYWxsYmFjayBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBzZXRTdGF0ZShzdGF0ZSwgY2FsbGJhY2sgPSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGhpc1tST09UXSAhPT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFsbG93V3JhcHBlcjo6c2V0U3RhdGUoKSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhlIHJvb3QnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5zdGFuY2UoKSA9PT0gbnVsbCB8fCB0aGlzW1JFTkRFUkVSXS5nZXROb2RlKCkubm9kZVR5cGUgIT09ICdjbGFzcycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhbGxvd1dyYXBwZXI6OnNldFN0YXRlKCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGNsYXNzIGNvbXBvbmVudHMnKTtcbiAgICB9XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhY3RXcmFwcGVyOjpzZXRTdGF0ZSgpIGV4cGVjdHMgYSBmdW5jdGlvbiBhcyBpdHMgc2Vjb25kIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgdGhpcy5zaW5nbGUoJ3NldFN0YXRlJywgKCkgPT4ge1xuICAgICAgd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFkYXB0ZXIgPSBnZXRBZGFwdGVyKHRoaXNbT1BUSU9OU10pO1xuXG4gICAgICAgIGNvbnN0IGxpZmVjeWNsZXMgPSBnZXRBZGFwdGVyTGlmZWN5Y2xlcyhhZGFwdGVyKTtcblxuICAgICAgICBjb25zdCBub2RlID0gdGhpc1tSRU5ERVJFUl0uZ2V0Tm9kZSgpO1xuICAgICAgICBjb25zdCB7IGluc3RhbmNlIH0gPSBub2RlO1xuICAgICAgICBjb25zdCBwcmV2UHJvcHMgPSBpbnN0YW5jZS5wcm9wcztcbiAgICAgICAgY29uc3QgcHJldlN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgICAgIGNvbnN0IHByZXZDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcblxuICAgICAgICBjb25zdCBzdGF0ZVBheWxvYWQgPSB0eXBlb2Ygc3RhdGUgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IHN0YXRlLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJldlByb3BzKVxuICAgICAgICAgIDogc3RhdGU7XG5cbiAgICAgICAgLy8gcmV0dXJuaW5nIG51bGwgb3IgdW5kZWZpbmVkIHByZXZlbnRzIHRoZSB1cGRhdGUgaW4gUmVhY3QgMTYrXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEyNzU2XG4gICAgICAgIGNvbnN0IG1heWJlSGFzVXBkYXRlID0gIWxpZmVjeWNsZXMuc2V0U3RhdGUuc2tpcHNDb21wb25lbnREaWRVcGRhdGVPbk51bGxpc2hcbiAgICAgICAgICB8fCBzdGF0ZVBheWxvYWQgIT0gbnVsbDtcblxuICAgICAgICAvLyBXaGVuIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlIHdlIHNob3VsZG4ndCBjYWxsIGNvbXBvbmVudERpZFVwZGF0ZS5cbiAgICAgICAgLy8gc28gd2Ugc3B5IHNob3VsZENvbXBvbmVudFVwZGF0ZSB0byBnZXQgdGhlIHJlc3VsdC5cbiAgICAgICAgbGV0IHNob3VsZENvbXBvbmVudFVwZGF0ZVNweTtcbiAgICAgICAgbGV0IGdldENoaWxkQ29udGV4dFNweTtcbiAgICAgICAgbGV0IHNob3VsZFJlbmRlciA9IHRydWU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhdGhpc1tPUFRJT05TXS5kaXNhYmxlTGlmZWN5Y2xlTWV0aG9kc1xuICAgICAgICAgICYmIGluc3RhbmNlXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGxpZmVjeWNsZXMuY29tcG9uZW50RGlkVXBkYXRlXG4gICAgICAgICAgICAmJiBsaWZlY3ljbGVzLmNvbXBvbmVudERpZFVwZGF0ZS5vblNldFN0YXRlXG4gICAgICAgICAgICAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCB7IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogZ0RTRlAgfSA9IGxpZmVjeWNsZXM7XG4gICAgICAgICAgICBpZiAoZ0RTRlAgJiYgZ0RTRlAuaGFzU2hvdWxkQ29tcG9uZW50VXBkYXRlQnVnKSB7XG4gICAgICAgICAgICAgIG1vY2tTQ1VJZmdEU0ZQUmV0dXJuTm9uTnVsbChub2RlLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaG91bGRDb21wb25lbnRVcGRhdGVTcHkgPSBzcHlNZXRob2QoaW5zdGFuY2UsICdzaG91bGRDb21wb25lbnRVcGRhdGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbGlmZWN5Y2xlcy5nZXRDaGlsZENvbnRleHQuY2FsbGVkQnlSZW5kZXJlclxuICAgICAgICAgICAgJiYgdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgZ2V0Q2hpbGRDb250ZXh0U3B5ID0gc3B5TWV0aG9kKGluc3RhbmNlLCAnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2hvdWxkQ29tcG9uZW50VXBkYXRlU3B5ICYmIGlzUHVyZUNvbXBvbmVudChpbnN0YW5jZSkpIHtcbiAgICAgICAgICBzaG91bGRSZW5kZXIgPSBwdXJlQ29tcG9uZW50U2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAgICAgICAgICAgcHJldlByb3BzLFxuICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMsXG4gICAgICAgICAgICBwcmV2U3RhdGUsXG4gICAgICAgICAgICB7IC4uLnByZXZTdGF0ZSwgLi4uc3RhdGVQYXlsb2FkIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGRvbid0IHBhc3MgdGhlIHNldFN0YXRlIGNhbGxiYWNrIGhlcmVcbiAgICAgICAgLy8gdG8gZ3VhcmFudGVlIHRvIGNhbGwgdGhlIGNhbGxiYWNrIGFmdGVyIGZpbmlzaGluZyB0aGUgcmVuZGVyXG4gICAgICAgIGlmIChpbnN0YW5jZVtTRVRfU1RBVEVdKSB7XG4gICAgICAgICAgaW5zdGFuY2VbU0VUX1NUQVRFXShzdGF0ZVBheWxvYWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc3RhbmNlLnNldFN0YXRlKHN0YXRlUGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZENvbXBvbmVudFVwZGF0ZVNweSkge1xuICAgICAgICAgIHNob3VsZFJlbmRlciA9IHNob3VsZENvbXBvbmVudFVwZGF0ZVNweS5nZXRMYXN0UmV0dXJuVmFsdWUoKTtcbiAgICAgICAgICBzaG91bGRDb21wb25lbnRVcGRhdGVTcHkucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcbiAgICAgICAgICBtYXliZUhhc1VwZGF0ZVxuICAgICAgICAgICYmIHNob3VsZFJlbmRlclxuICAgICAgICAgICYmICF0aGlzW09QVElPTlNdLmRpc2FibGVMaWZlY3ljbGVNZXRob2RzXG4gICAgICAgICkge1xuICAgICAgICAgIHByaXZhdGVTZXRDaGlsZENvbnRleHQoYWRhcHRlciwgdGhpcywgaW5zdGFuY2UsIG5vZGUsIGdldENoaWxkQ29udGV4dFNweSk7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbGlmZWN5Y2xlcy5jb21wb25lbnREaWRVcGRhdGVcbiAgICAgICAgICAgICYmIGxpZmVjeWNsZXMuY29tcG9uZW50RGlkVXBkYXRlLm9uU2V0U3RhdGVcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbGlmZWN5Y2xlcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICAgICAgICAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIHNuYXBzaG90KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGlmIChsaWZlY3ljbGVzLmNvbXBvbmVudERpZFVwZGF0ZS5wcmV2Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgcHJldkNvbnRleHQpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgLy8gY2FsbCB0aGUgc2V0U3RhdGUgY2FsbGJhY2tcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKGFkYXB0ZXIuaW52b2tlU2V0U3RhdGVDYWxsYmFjaykge1xuICAgICAgICAgICAgYWRhcHRlci5pbnZva2VTZXRTdGF0ZUNhbGxiYWNrKGluc3RhbmNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBzZXRzIHRoZSBjb250ZXh0IG9mIHRoZSByb290IGNvbXBvbmVudCwgYW5kIHJlLXJlbmRlcnMuIFVzZWZ1bCBmb3Igd2hlbiB5b3UgYXJlXG4gICAqIHdhbnRpbmcgdG8gdGVzdCBob3cgdGhlIGNvbXBvbmVudCBiZWhhdmVzIG92ZXIgdGltZSB3aXRoIGNoYW5naW5nIGNvbnRleHRzLlxuICAgKlxuICAgKiBOT1RFOiBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB3cmFwcGVyIGluc3RhbmNlIHRoYXQgaXMgYWxzbyB0aGUgcm9vdCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgb2JqZWN0XG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIHNldENvbnRleHQoY29udGV4dCkge1xuICAgIGlmICh0aGlzW1JPT1RdICE9PSB0aGlzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWxsb3dXcmFwcGVyOjpzZXRDb250ZXh0KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoZSByb290Jyk7XG4gICAgfVxuICAgIGlmICghdGhpc1tPUFRJT05TXS5jb250ZXh0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWxsb3dXcmFwcGVyOjpzZXRDb250ZXh0KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGEgd3JhcHBlciB0aGF0IHdhcyBvcmlnaW5hbGx5IHBhc3NlZCBhIGNvbnRleHQgb3B0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlcmVuZGVyKG51bGwsIGNvbnRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IGEgZ2l2ZW4gcmVhY3QgZWxlbWVudCBleGlzdHMgaW4gdGhlIHNoYWxsb3cgcmVuZGVyIHRyZWUuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqIGBgYFxuICAgKiBjb25zdCB3cmFwcGVyID0gc2hhbGxvdyg8TXlDb21wb25lbnQgLz4pO1xuICAgKiBleHBlY3Qod3JhcHBlci5jb250YWlucyg8ZGl2IGNsYXNzTmFtZT1cImZvbyBiYXJcIiAvPikpLnRvLmVxdWFsKHRydWUpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR8QXJyYXk8UmVhY3RFbGVtZW50Pn0gbm9kZU9yTm9kZXNcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBjb250YWlucyhub2RlT3JOb2Rlcykge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSBnZXRBZGFwdGVyKHRoaXNbT1BUSU9OU10pO1xuICAgIGlmICghaXNSZWFjdEVsZW1lbnRBbGlrZShub2RlT3JOb2RlcywgYWRhcHRlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhbGxvd1dyYXBwZXI6OmNvbnRhaW5zKCkgY2FuIG9ubHkgYmUgY2FsbGVkIHdpdGggYSBSZWFjdEVsZW1lbnQgKG9yIGFuIGFycmF5IG9mIHRoZW0pLCBhIHN0cmluZywgb3IgYSBudW1iZXIgYXMgYW4gYXJndW1lbnQuJyk7XG4gICAgfVxuICAgIGNvbnN0IHByZWRpY2F0ZSA9IEFycmF5LmlzQXJyYXkobm9kZU9yTm9kZXMpXG4gICAgICA/IChvdGhlcikgPT4gY29udGFpbnNDaGlsZHJlblN1YkFycmF5KFxuICAgICAgICBub2RlRXF1YWwsXG4gICAgICAgIG90aGVyLFxuICAgICAgICBub2RlT3JOb2Rlcy5tYXAoKG5vZGUpID0+IGFkYXB0ZXIuZWxlbWVudFRvTm9kZShub2RlKSksXG4gICAgICApXG4gICAgICA6IChvdGhlcikgPT4gbm9kZUVxdWFsKGFkYXB0ZXIuZWxlbWVudFRvTm9kZShub2RlT3JOb2RlcyksIG90aGVyKTtcblxuICAgIHJldHVybiBmaW5kV2hlcmVVbndyYXBwZWQodGhpcywgcHJlZGljYXRlKS5sZW5ndGggPiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IGEgZ2l2ZW4gcmVhY3QgZWxlbWVudCBleGlzdHMgaW4gdGhlIHNoYWxsb3cgcmVuZGVyIHRyZWUuXG4gICAqIE1hdGNoIGlzIGJhc2VkIG9uIHRoZSBleHBlY3RlZCBlbGVtZW50IGFuZCBub3Qgb24gd3JhcHBlcnMgZWxlbWVudC5cbiAgICogSXQgd2lsbCBkZXRlcm1pbmUgaWYgb25lIG9mIHRoZSB3cmFwcGVycyBlbGVtZW50IFwibG9va3MgbGlrZVwiIHRoZSBleHBlY3RlZFxuICAgKiBlbGVtZW50IGJ5IGNoZWNraW5nIGlmIGFsbCBwcm9wcyBvZiB0aGUgZXhwZWN0ZWQgZWxlbWVudCBhcmUgcHJlc2VudFxuICAgKiBvbiB0aGUgd3JhcHBlcnMgZWxlbWVudCBhbmQgZXF1YWxzIHRvIGVhY2ggb3RoZXIuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqIGBgYFxuICAgKiAvLyBNeUNvbXBvbmVudCBvdXRwdXRzIDxkaXY+PGRpdiBjbGFzcz1cImZvb1wiPkhlbGxvPC9kaXY+PC9kaXY+XG4gICAqIGNvbnN0IHdyYXBwZXIgPSBzaGFsbG93KDxNeUNvbXBvbmVudCAvPik7XG4gICAqIGV4cGVjdCh3cmFwcGVyLmNvbnRhaW5zTWF0Y2hpbmdFbGVtZW50KDxkaXY+SGVsbG88L2Rpdj4pKS50by5lcXVhbCh0cnVlKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBub2RlXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgY29udGFpbnNNYXRjaGluZ0VsZW1lbnQobm9kZSkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSBnZXRBZGFwdGVyKHRoaXNbT1BUSU9OU10pO1xuICAgIGNvbnN0IHJzdE5vZGUgPSBhZGFwdGVyLmVsZW1lbnRUb05vZGUobm9kZSk7XG4gICAgY29uc3QgcHJlZGljYXRlID0gKG90aGVyKSA9PiBub2RlTWF0Y2hlcyhyc3ROb2RlLCBvdGhlciwgKGEsIGIpID0+IGEgPD0gYik7XG4gICAgcmV0dXJuIGZpbmRXaGVyZVVud3JhcHBlZCh0aGlzLCBwcmVkaWNhdGUpLmxlbmd0aCA+IDA7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgYWxsIHRoZSBnaXZlbiByZWFjdCBlbGVtZW50cyBleGlzdCBpbiB0aGUgc2hhbGxvdyByZW5kZXIgdHJlZS5cbiAgICogTWF0Y2ggaXMgYmFzZWQgb24gdGhlIGV4cGVjdGVkIGVsZW1lbnQgYW5kIG5vdCBvbiB3cmFwcGVycyBlbGVtZW50LlxuICAgKiBJdCB3aWxsIGRldGVybWluZSBpZiBvbmUgb2YgdGhlIHdyYXBwZXJzIGVsZW1lbnQgXCJsb29rcyBsaWtlXCIgdGhlIGV4cGVjdGVkXG4gICAqIGVsZW1lbnQgYnkgY2hlY2tpbmcgaWYgYWxsIHByb3BzIG9mIHRoZSBleHBlY3RlZCBlbGVtZW50IGFyZSBwcmVzZW50XG4gICAqIG9uIHRoZSB3cmFwcGVycyBlbGVtZW50IGFuZCBlcXVhbHMgdG8gZWFjaCBvdGhlci5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogYGBgXG4gICAqIGNvbnN0IHdyYXBwZXIgPSBzaGFsbG93KDxNeUNvbXBvbmVudCAvPik7XG4gICAqIGV4cGVjdCh3cmFwcGVyLmNvbnRhaW5zQWxsTWF0Y2hpbmdFbGVtZW50cyhbXG4gICAqICAgPGRpdj5IZWxsbzwvZGl2PixcbiAgICogICA8ZGl2Pkdvb2RieWU8L2Rpdj4sXG4gICAqIF0pKS50by5lcXVhbCh0cnVlKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8UmVhY3RFbGVtZW50Pn0gbm9kZXNcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBjb250YWluc0FsbE1hdGNoaW5nRWxlbWVudHMobm9kZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub2RlcyBzaG91bGQgYmUgYW4gQXJyYXknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZXMuZXZlcnkoKG5vZGUpID0+IHRoaXMuY29udGFpbnNNYXRjaGluZ0VsZW1lbnQobm9kZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IG9uZSBvZiB0aGUgZ2l2ZW4gcmVhY3QgZWxlbWVudHMgZXhpc3RzIGluIHRoZSBzaGFsbG93IHJlbmRlciB0cmVlLlxuICAgKiBNYXRjaCBpcyBiYXNlZCBvbiB0aGUgZXhwZWN0ZWQgZWxlbWVudCBhbmQgbm90IG9uIHdyYXBwZXJzIGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgZGV0ZXJtaW5lIGlmIG9uZSBvZiB0aGUgd3JhcHBlcnMgZWxlbWVudCBcImxvb2tzIGxpa2VcIiB0aGUgZXhwZWN0ZWRcbiAgICogZWxlbWVudCBieSBjaGVja2luZyBpZiBhbGwgcHJvcHMgb2YgdGhlIGV4cGVjdGVkIGVsZW1lbnQgYXJlIHByZXNlbnRcbiAgICogb24gdGhlIHdyYXBwZXJzIGVsZW1lbnQgYW5kIGVxdWFscyB0byBlYWNoIG90aGVyLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiBgYGBcbiAgICogY29uc3Qgd3JhcHBlciA9IHNoYWxsb3coPE15Q29tcG9uZW50IC8+KTtcbiAgICogZXhwZWN0KHdyYXBwZXIuY29udGFpbnNBbnlNYXRjaGluZ0VsZW1lbnRzKFtcbiAgICogICA8ZGl2PkhlbGxvPC9kaXY+LFxuICAgKiAgIDxkaXY+R29vZGJ5ZTwvZGl2PixcbiAgICogXSkpLnRvLmVxdWFsKHRydWUpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxSZWFjdEVsZW1lbnQ+fSBub2Rlc1xuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGNvbnRhaW5zQW55TWF0Y2hpbmdFbGVtZW50cyhub2Rlcykge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG5vZGVzKSAmJiBub2Rlcy5zb21lKChub2RlKSA9PiB0aGlzLmNvbnRhaW5zTWF0Y2hpbmdFbGVtZW50KG5vZGUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCBhIGdpdmVuIHJlYWN0IGVsZW1lbnQgZXhpc3RzIGluIHRoZSByZW5kZXIgdHJlZS5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICogYGBgXG4gICAqIGNvbnN0IHdyYXBwZXIgPSBzaGFsbG93KDxNeUNvbXBvbmVudCAvPik7XG4gICAqIGV4cGVjdCh3cmFwcGVyLmNvbnRhaW5zKDxkaXYgY2xhc3NOYW1lPVwiZm9vIGJhclwiIC8+KSkudG8uZXF1YWwodHJ1ZSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbm9kZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGVxdWFscyhub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdlcXVhbHMnLCAoKSA9PiBub2RlRXF1YWwodGhpcy5nZXROb2RlSW50ZXJuYWwoKSwgbm9kZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IGEgZ2l2ZW4gcmVhY3QgZWxlbWVudCBtYXRjaGVzIHRoZSByZW5kZXIgdHJlZS5cbiAgICogTWF0Y2ggaXMgYmFzZWQgb24gdGhlIGV4cGVjdGVkIGVsZW1lbnQgYW5kIG5vdCBvbiB3cmFwcGVyIHJvb3Qgbm9kZS5cbiAgICogSXQgd2lsbCBkZXRlcm1pbmUgaWYgdGhlIHdyYXBwZXIgcm9vdCBub2RlIFwibG9va3MgbGlrZVwiIHRoZSBleHBlY3RlZFxuICAgKiBlbGVtZW50IGJ5IGNoZWNraW5nIGlmIGFsbCBwcm9wcyBvZiB0aGUgZXhwZWN0ZWQgZWxlbWVudCBhcmUgcHJlc2VudFxuICAgKiBvbiB0aGUgd3JhcHBlciByb290IG5vZGUgYW5kIGVxdWFscyB0byBlYWNoIG90aGVyLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKiBgYGBcbiAgICogLy8gTXlDb21wb25lbnQgb3V0cHV0cyA8ZGl2IGNsYXNzPVwiZm9vXCI+SGVsbG88L2Rpdj5cbiAgICogY29uc3Qgd3JhcHBlciA9IHNoYWxsb3coPE15Q29tcG9uZW50IC8+KTtcbiAgICogZXhwZWN0KHdyYXBwZXIubWF0Y2hlc0VsZW1lbnQoPGRpdj5IZWxsbzwvZGl2PikpLnRvLmVxdWFsKHRydWUpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5vZGVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBtYXRjaGVzRWxlbWVudChub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdtYXRjaGVzRWxlbWVudCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGFkYXB0ZXIgPSBnZXRBZGFwdGVyKHRoaXNbT1BUSU9OU10pO1xuICAgICAgY29uc3QgcnN0Tm9kZSA9IGFkYXB0ZXIuZWxlbWVudFRvTm9kZShub2RlKTtcbiAgICAgIHJldHVybiBub2RlTWF0Y2hlcyhyc3ROb2RlLCB0aGlzLmdldE5vZGVJbnRlcm5hbCgpLCAoYSwgYikgPT4gYSA8PSBiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBldmVyeSBub2RlIGluIHRoZSByZW5kZXIgdHJlZSBvZiB0aGUgY3VycmVudCB3cmFwcGVyIHRoYXQgbWF0Y2hlcyB0aGUgcHJvdmlkZWQgc2VsZWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7RW56eW1lU2VsZWN0b3J9IHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIGZpbmQoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwKHJlZHVjZVRyZWVzQnlTZWxlY3RvcihzZWxlY3RvciwgdGhpcy5nZXROb2Rlc0ludGVybmFsKCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGN1cnJlbnQgbm9kZSBtYXRjaGVzIGEgcHJvdmlkZWQgc2VsZWN0b3IuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgb2YgYSBzaW5nbGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtFbnp5bWVTZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpcyhzZWxlY3Rvcikge1xuICAgIGNvbnN0IHByZWRpY2F0ZSA9IGJ1aWxkUHJlZGljYXRlKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ2lzJywgKG4pID0+IHByZWRpY2F0ZShuKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb21wb25lbnQgcmVuZGVyZWQgbm90aGluZywgaS5lLiwgbnVsbCBvciBmYWxzZS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0VtcHR5UmVuZGVyKCkge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5nZXROb2Rlc0ludGVybmFsKCk7XG5cbiAgICByZXR1cm4gbm9kZXMuZXZlcnkoKG4pID0+IGlzRW1wdHlWYWx1ZShuKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyB3cmFwcGVyIGluc3RhbmNlIHdpdGggb25seSB0aGUgbm9kZXMgb2YgdGhlIGN1cnJlbnQgd3JhcHBlciBpbnN0YW5jZSB0aGF0IG1hdGNoXG4gICAqIHRoZSBwcm92aWRlZCBwcmVkaWNhdGUgZnVuY3Rpb24uIFRoZSBwcmVkaWNhdGUgc2hvdWxkIHJlY2VpdmUgYSB3cmFwcGVkIG5vZGUgYXMgaXRzIGZpcnN0XG4gICAqIGFyZ3VtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAgICogQHJldHVybnMge1NoYWxsb3dXcmFwcGVyfVxuICAgKi9cbiAgZmlsdGVyV2hlcmUocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZpbHRlcldoZXJlVW53cmFwcGVkKHRoaXMsIChuKSA9PiBwcmVkaWNhdGUodGhpcy53cmFwKG4pKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyB3cmFwcGVyIGluc3RhbmNlIHdpdGggb25seSB0aGUgbm9kZXMgb2YgdGhlIGN1cnJlbnQgd3JhcHBlciBpbnN0YW5jZSB0aGF0IG1hdGNoXG4gICAqIHRoZSBwcm92aWRlZCBzZWxlY3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtFbnp5bWVTZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICogQHJldHVybnMge1NoYWxsb3dXcmFwcGVyfVxuICAgKi9cbiAgZmlsdGVyKHNlbGVjdG9yKSB7XG4gICAgY29uc3QgcHJlZGljYXRlID0gYnVpbGRQcmVkaWNhdGUoc2VsZWN0b3IpO1xuICAgIHJldHVybiBmaWx0ZXJXaGVyZVVud3JhcHBlZCh0aGlzLCBwcmVkaWNhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgd3JhcHBlciBpbnN0YW5jZSB3aXRoIG9ubHkgdGhlIG5vZGVzIG9mIHRoZSBjdXJyZW50IHdyYXBwZXIgdGhhdCBkaWQgbm90IG1hdGNoXG4gICAqIHRoZSBwcm92aWRlZCBzZWxlY3Rvci4gRXNzZW50aWFsbHkgdGhlIGludmVyc2Ugb2YgYGZpbHRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RW56eW1lU2VsZWN0b3J9IHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIG5vdChzZWxlY3Rvcikge1xuICAgIGNvbnN0IHByZWRpY2F0ZSA9IGJ1aWxkUHJlZGljYXRlKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gZmlsdGVyV2hlcmVVbndyYXBwZWQodGhpcywgKG4pID0+ICFwcmVkaWNhdGUobikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgb2YgdGhlIHJlbmRlcmVkIHRleHQgb2YgdGhlIGN1cnJlbnQgcmVuZGVyIHRyZWUuICBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZVxuICAgKiBsb29rZWQgYXQgd2l0aCBza2VwdGljaXNtIGlmIGJlaW5nIHVzZWQgdG8gdGVzdCB3aGF0IHRoZSBhY3R1YWwgSFRNTCBvdXRwdXQgb2YgdGhlIGNvbXBvbmVudFxuICAgKiB3aWxsIGJlLiBJZiB0aGF0IGlzIHdoYXQgeW91IHdvdWxkIGxpa2UgdG8gdGVzdCwgdXNlIGVuenltZSdzIGByZW5kZXJgIGZ1bmN0aW9uIGluc3RlYWQuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgb2YgYSBzaW5nbGUgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCd0ZXh0JywgZ2V0VGV4dEZyb21Ob2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBIVE1MIG9mIHRoZSBub2RlLlxuICAgKlxuICAgKiBOT1RFOiBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB3cmFwcGVyIG9mIGEgc2luZ2xlIG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBodG1sKCkge1xuICAgIHJldHVybiB0aGlzLnNpbmdsZSgnaHRtbCcsIChuKSA9PiB7XG4gICAgICBpZiAodGhpcy50eXBlKCkgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgICAgY29uc3QgYWRhcHRlciA9IGdldEFkYXB0ZXIodGhpc1tPUFRJT05TXSk7XG4gICAgICBjb25zdCByZW5kZXJlciA9IGFkYXB0ZXIuY3JlYXRlUmVuZGVyZXIoeyAuLi50aGlzW09QVElPTlNdLCBtb2RlOiAnc3RyaW5nJyB9KTtcbiAgICAgIHJldHVybiByZW5kZXJlci5yZW5kZXIoYWRhcHRlci5ub2RlVG9FbGVtZW50KG4pKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG5vZGUgcmVuZGVyZWQgdG8gSFRNTCBhbmQgd3JhcHBlZCBpbiBhIENoZWVyaW9XcmFwcGVyLlxuICAgKlxuICAgKiBOT1RFOiBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB3cmFwcGVyIG9mIGEgc2luZ2xlIG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtDaGVlcmlvV3JhcHBlcn1cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBodG1sID0gdGhpcy5odG1sKCk7XG4gICAgcmV0dXJuIGxvYWRDaGVlcmlvUm9vdChodG1sKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHNpbXVsYXRlIGV2ZW50cy4gUGFzcyBhbiBldmVudG5hbWUgYW5kIChvcHRpb25hbGx5KSBldmVudCBhcmd1bWVudHMuIFRoaXMgbWV0aG9kIG9mXG4gICAqIHRlc3RpbmcgZXZlbnRzIHNob3VsZCBiZSBtZXQgd2l0aCBzb21lIHNrZXB0aWNpc20uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIHNpbXVsYXRlKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdzaW11bGF0ZScsIChuKSA9PiB7XG4gICAgICB0aGlzW1JFTkRFUkVSXS5zaW11bGF0ZUV2ZW50KG4sIGV2ZW50LCAuLi5hcmdzKTtcbiAgICAgIHRoaXNbUk9PVF0udXBkYXRlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHNpbXVsYXRlIHRocm93aW5nIGEgcmVuZGVyaW5nIGVycm9yLiBQYXNzIGFuIGVycm9yIHRvIHRocm93LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXJyb3JcbiAgICogQHJldHVybnMge1NoYWxsb3dXcmFwcGVyfVxuICAgKi9cbiAgc2ltdWxhdGVFcnJvcihlcnJvcikge1xuICAgIC8vIGluIHNoYWxsb3csIHRoZSBcInJvb3RcIiBpcyB0aGUgXCJyZW5kZXJlZFwiIHRoaW5nLlxuXG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdzaW11bGF0ZUVycm9yJywgKHRoaXNOb2RlKSA9PiB7XG4gICAgICBpZiAodGhpc05vZGUubm9kZVR5cGUgPT09ICdob3N0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTaGFsbG93V3JhcHBlcjo6c2ltdWxhdGVFcnJvcigpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBjdXN0b20gY29tcG9uZW50cycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZW5kZXJlciA9IHRoaXNbUkVOREVSRVJdO1xuICAgICAgaWYgKHR5cGVvZiByZW5kZXJlci5zaW11bGF0ZUVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3lvdXIgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IGBzaW11bGF0ZUVycm9yYC4gVHJ5IHVwZ3JhZGluZyBpdCEnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm9vdE5vZGUgPSBnZXRSb290Tm9kZUludGVybmFsKHRoaXMpO1xuICAgICAgY29uc3Qgbm9kZUhpZXJhcmNoeSA9IFt0aGlzTm9kZV0uY29uY2F0KG5vZGVQYXJlbnRzKHRoaXMsIHRoaXNOb2RlKSk7XG4gICAgICByZW5kZXJlci5zaW11bGF0ZUVycm9yKG5vZGVIaWVyYXJjaHksIHJvb3ROb2RlLCBlcnJvcik7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb3BzIGhhc2ggZm9yIHRoZSBjdXJyZW50IG5vZGUgb2YgdGhlIHdyYXBwZXIuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgb2YgYSBzaW5nbGUgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHByb3BzKCkge1xuICAgIHJldHVybiB0aGlzLnNpbmdsZSgncHJvcHMnLCBwcm9wc09mTm9kZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhdGUgaGFzaCBmb3IgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgd3JhcHBlci4gT3B0aW9uYWxseSBwYXNzIGluIGEgcHJvcCBuYW1lIGFuZCBpdFxuICAgKiB3aWxsIHJldHVybiBqdXN0IHRoYXQgdmFsdWUuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgb2YgYSBzaW5nbGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHN0YXRlKG5hbWUpIHtcbiAgICBpZiAodGhpc1tST09UXSAhPT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFsbG93V3JhcHBlcjo6c3RhdGUoKSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhlIHJvb3QnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW5zdGFuY2UoKSA9PT0gbnVsbCB8fCB0aGlzW1JFTkRFUkVSXS5nZXROb2RlKCkubm9kZVR5cGUgIT09ICdjbGFzcycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2hhbGxvd1dyYXBwZXI6OnN0YXRlKCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGNsYXNzIGNvbXBvbmVudHMnKTtcbiAgICB9XG4gICAgY29uc3QgX3N0YXRlID0gdGhpcy5zaW5nbGUoJ3N0YXRlJywgKCkgPT4gdGhpcy5pbnN0YW5jZSgpLnN0YXRlKTtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoX3N0YXRlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgU2hhbGxvd1dyYXBwZXI6OnN0YXRlKFwiJHtuYW1lfVwiKSByZXF1aXJlcyB0aGF0IFxcYHN0YXRlXFxgIG5vdCBiZSBcXGBudWxsXFxgIG9yIFxcYHVuZGVmaW5lZFxcYGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9zdGF0ZVtuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIF9zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb250ZXh0IGhhc2ggZm9yIHRoZSByb290IG5vZGUgb2YgdGhlIHdyYXBwZXIuXG4gICAqIE9wdGlvbmFsbHkgcGFzcyBpbiBhIHByb3AgbmFtZSBhbmQgaXQgd2lsbCByZXR1cm4ganVzdCB0aGF0IHZhbHVlLlxuICAgKlxuICAgKiBOT1RFOiBjYW4gb25seSBiZSBjYWxsZWQgb24gYSB3cmFwcGVyIG9mIGEgc2luZ2xlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIChvcHRpb25hbClcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBjb250ZXh0KG5hbWUpIHtcbiAgICBpZiAodGhpc1tST09UXSAhPT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFsbG93V3JhcHBlcjo6Y29udGV4dCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB0aGUgcm9vdCcpO1xuICAgIH1cbiAgICBpZiAoIXRoaXNbT1BUSU9OU10uY29udGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFsbG93V3JhcHBlcjo6Y29udGV4dCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgdGhhdCB3YXMgb3JpZ2luYWxseSBwYXNzZWQgYSBjb250ZXh0IG9wdGlvbicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnN0YW5jZSgpID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWxsb3dXcmFwcGVyOjpjb250ZXh0KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHdyYXBwZWQgbm9kZXMgdGhhdCBoYXZlIGEgbm9uLW51bGwgaW5zdGFuY2UnKTtcbiAgICB9XG4gICAgY29uc3QgX2NvbnRleHQgPSB0aGlzLnNpbmdsZSgnY29udGV4dCcsICgpID0+IHRoaXMuaW5zdGFuY2UoKS5jb250ZXh0KTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIF9jb250ZXh0W25hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gX2NvbnRleHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyB3cmFwcGVyIHdpdGggYWxsIG9mIHRoZSBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCB3cmFwcGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0VuenltZVNlbGVjdG9yfSBbc2VsZWN0b3JdXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIGNoaWxkcmVuKHNlbGVjdG9yKSB7XG4gICAgY29uc3QgYWxsQ2hpbGRyZW4gPSB0aGlzLmZsYXRNYXAoKG4pID0+IGNoaWxkcmVuT2ZOb2RlKG4uZ2V0Tm9kZUludGVybmFsKCkpKTtcbiAgICByZXR1cm4gc2VsZWN0b3IgPyBhbGxDaGlsZHJlbi5maWx0ZXIoc2VsZWN0b3IpIDogYWxsQ2hpbGRyZW47XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyB3cmFwcGVyIHdpdGggYSBzcGVjaWZpYyBjaGlsZFxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2luZGV4XVxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBjaGlsZEF0KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuc2luZ2xlKCdjaGlsZEF0JywgKCkgPT4gdGhpcy5jaGlsZHJlbigpLmF0KGluZGV4KSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHdyYXBwZXIgYXJvdW5kIGFsbCBvZiB0aGUgcGFyZW50cy9hbmNlc3RvcnMgb2YgdGhlIHdyYXBwZXIuIERvZXMgbm90IGluY2x1ZGUgdGhlIG5vZGVcbiAgICogaW4gdGhlIGN1cnJlbnQgd3JhcHBlci5cbiAgICpcbiAgICogTk9URTogY2FuIG9ubHkgYmUgY2FsbGVkIG9uIGEgd3JhcHBlciBvZiBhIHNpbmdsZSBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge0VuenltZVNlbGVjdG9yfSBbc2VsZWN0b3JdXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIHBhcmVudHMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ3BhcmVudHMnLCAobikgPT4ge1xuICAgICAgY29uc3QgYWxsUGFyZW50cyA9IHRoaXMud3JhcChub2RlUGFyZW50cyh0aGlzLCBuKSk7XG4gICAgICByZXR1cm4gc2VsZWN0b3IgPyBhbGxQYXJlbnRzLmZpbHRlcihzZWxlY3RvcikgOiBhbGxQYXJlbnRzO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgaW1tZWRpYXRlIHBhcmVudCBvZiB0aGUgY3VycmVudCBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdE1hcCgobikgPT4gW24ucGFyZW50cygpLmdldCgwKV0pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7RW56eW1lU2VsZWN0b3J9IHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIGNsb3Nlc3Qoc2VsZWN0b3IpIHtcbiAgICBpZiAodGhpcy5pcyhzZWxlY3RvcikpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGluZ0FuY2VzdG9ycyA9IHRoaXMucGFyZW50cygpLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgcmV0dXJuIG1hdGNoaW5nQW5jZXN0b3JzLmxlbmd0aCA+IDAgPyBtYXRjaGluZ0FuY2VzdG9ycy5maXJzdCgpIDogdGhpcy5maW5kV2hlcmUoKCkgPT4gZmFsc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoYWxsb3cgcmVuZGVycyB0aGUgY3VycmVudCBub2RlIGFuZCByZXR1cm5zIGEgc2hhbGxvdyB3cmFwcGVyIGFyb3VuZCBpdC5cbiAgICpcbiAgICogTk9URTogY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHdyYXBwZXIgb2YgYSBzaW5nbGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybnMge1NoYWxsb3dXcmFwcGVyfVxuICAgKi9cbiAgc2hhbGxvdyhvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ3NoYWxsb3cnLCAobikgPT4ge1xuICAgICAgY29uc3QgY2hpbGRPcHRpb25zID0gbWFrZUluaGVyaXRlZENoaWxkT3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzLndyYXAoZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKS5ub2RlVG9FbGVtZW50KG4pLCBudWxsLCBjaGlsZE9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHByb3Agd2l0aCB0aGUgZ2l2ZW4gbmFtZSBvZiB0aGUgY3VycmVudCBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gcHJvcE5hbWVcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBwcm9wKHByb3BOYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMoKVtwcm9wTmFtZV07XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBpbnZva2UgYSBmdW5jdGlvbiBwcm9wLlxuICAgKiBXaWxsIGludm9rZSBhbiBmdW5jdGlvbiBwcm9wIGFuZCByZXR1cm4gaXRzIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcbiAgICogQHJldHVybnMge0FueX1cbiAgICovXG4gIGludm9rZShwcm9wTmFtZSkge1xuICAgIHJldHVybiB0aGlzLnNpbmdsZSgnaW52b2tlJywgKCkgPT4ge1xuICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMucHJvcChwcm9wTmFtZSk7XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2hhbGxvd1dyYXBwZXI6Omludm9rZSgpIHJlcXVpcmVzIHRoZSBuYW1lIG9mIGEgcHJvcCB3aG9zZSB2YWx1ZSBpcyBhIGZ1bmN0aW9uJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBoYW5kbGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzW1JPT1RdLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB3cmFwcGVyIG9mIHRoZSBub2RlIHJlbmRlcmVkIGJ5IHRoZSBwcm92aWRlZCByZW5kZXIgcHJvcC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICovXG4gIHJlbmRlclByb3AocHJvcE5hbWUpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKTtcbiAgICBpZiAodHlwZW9mIGFkYXB0ZXIud3JhcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3lvdXIgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IGB3cmFwYC4gVHJ5IHVwZ3JhZGluZyBpdCEnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ3JlbmRlclByb3AnLCAobikgPT4ge1xuICAgICAgaWYgKG4ubm9kZVR5cGUgPT09ICdob3N0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTaGFsbG93V3JhcHBlcjo6cmVuZGVyUHJvcCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBjdXN0b20gY29tcG9uZW50cycpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwcm9wTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignU2hhbGxvd1dyYXBwZXI6OnJlbmRlclByb3AoKTogYHByb3BOYW1lYCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcHMoKTtcbiAgICAgIGlmICghaGFzKHByb3BzLCBwcm9wTmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaGFsbG93V3JhcHBlcjo6cmVuZGVyUHJvcCgpOiBubyBwcm9wIGNhbGxlZCDigJwke3Byb3BOYW1lfeKAnCBmb3VuZGApO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgU2hhbGxvd1dyYXBwZXI6OnJlbmRlclByb3AoKTogZXhwZWN0ZWQgcHJvcCDigJwke3Byb3BOYW1lfeKAnCB0byBjb250YWluIGEgZnVuY3Rpb24sIGJ1dCBpdCBob2xkcyDigJwke3R5cGVvZiBwcm9wVmFsdWV94oCcYCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gcHJvcFZhbHVlKC4uLmFyZ3MpO1xuICAgICAgICBjb25zdCB3cmFwcGVkID0gYWRhcHRlci53cmFwKGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwKHdyYXBwZWQsIG51bGwsIHRoaXNbT1BUSU9OU10pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXkgYXNzaWduZWQgdG8gdGhlIGN1cnJlbnQgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIGtleSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ2tleScsIChuKSA9PiAobi5rZXkgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBuLmtleSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHR5cGUgb2YgdGhlIGN1cnJlbnQgbm9kZSBvZiB0aGlzIHdyYXBwZXIuIElmIGl0J3MgYSBjb21wb3NpdGUgY29tcG9uZW50LCB0aGlzIHdpbGxcbiAgICogYmUgdGhlIGNvbXBvbmVudCBjb25zdHJ1Y3Rvci4gSWYgaXQncyBhIG5hdGl2ZSBET00gbm9kZSwgaXQgd2lsbCBiZSBhIHN0cmluZyBvZiB0aGUgdGFnIG5hbWUuXG4gICAqIElmIGl0J3MgbnVsbCwgaXQgd2lsbCBiZSBudWxsLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfEZ1bmN0aW9ufG51bGx9XG4gICAqL1xuICB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLnNpbmdsZSgndHlwZScsIChuKSA9PiB0eXBlT2ZOb2RlKG4pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IG5vZGUgb2YgdGhpcyB3cmFwcGVyLlxuICAgKlxuICAgKiBJbiBvcmRlciBvZiBwcmVjZWRlbmNlID0+IHR5cGUuZGlzcGxheU5hbWUgLT4gdHlwZS5uYW1lIC0+IHR5cGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBuYW1lKCkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSBnZXRBZGFwdGVyKHRoaXNbT1BUSU9OU10pO1xuICAgIHJldHVybiB0aGlzLnNpbmdsZSgnbmFtZScsIChuKSA9PiAoXG4gICAgICBhZGFwdGVyLmRpc3BsYXlOYW1lT2ZOb2RlID8gYWRhcHRlci5kaXNwbGF5TmFtZU9mTm9kZShuKSA6IGRpc3BsYXlOYW1lT2ZOb2RlKG4pXG4gICAgKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgY3VycmVudCBub2RlIGhhcyB0aGUgZ2l2ZW4gY2xhc3MgbmFtZSBvciBub3QuXG4gICAqXG4gICAqIE5PVEU6IGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBhIHdyYXBwZXIgb2YgYSBzaW5nbGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGNsYXNzTmFtZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJyAmJiBjbGFzc05hbWUuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybignSXQgbG9va3MgbGlrZSB5b3VcXCdyZSBjYWxsaW5nIGBTaGFsbG93V3JhcHBlcjo6aGFzQ2xhc3MoKWAgd2l0aCBhIENTUyBzZWxlY3Rvci4gaGFzQ2xhc3MoKSBleHBlY3RzIGEgY2xhc3MgbmFtZSwgbm90IGEgQ1NTIHNlbGVjdG9yLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zaW5nbGUoJ2hhc0NsYXNzJywgKG4pID0+IGhhc0NsYXNzTmFtZShuLCBjbGFzc05hbWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyB0aHJvdWdoIGVhY2ggbm9kZSBvZiB0aGUgY3VycmVudCB3cmFwcGVyIGFuZCBleGVjdXRlcyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gd2l0aCBhXG4gICAqIHdyYXBwZXIgYXJvdW5kIHRoZSBjb3JyZXNwb25kaW5nIG5vZGUgcGFzc2VkIGluIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHJldHVybnMge1NoYWxsb3dXcmFwcGVyfVxuICAgKi9cbiAgZm9yRWFjaChmbikge1xuICAgIHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpLmZvckVhY2goKG4sIGkpID0+IGZuLmNhbGwodGhpcywgdGhpcy53cmFwKG4pLCBpKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTWFwcyB0aGUgY3VycmVudCBhcnJheSBvZiBub2RlcyB0byBhbm90aGVyIGFycmF5LiBFYWNoIG5vZGUgaXMgcGFzc2VkIGluIGFzIGEgYFNoYWxsb3dXcmFwcGVyYFxuICAgKiB0byB0aGUgbWFwIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqL1xuICBtYXAoZm4pIHtcbiAgICByZXR1cm4gdGhpcy5nZXROb2Rlc0ludGVybmFsKCkubWFwKChuLCBpKSA9PiBmbi5jYWxsKHRoaXMsIHRoaXMud3JhcChuKSwgaSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZHVjZXMgdGhlIGN1cnJlbnQgYXJyYXkgb2Ygbm9kZXMgdG8gYSB2YWx1ZS4gRWFjaCBub2RlIGlzIHBhc3NlZCBpbiBhcyBhIGBTaGFsbG93V3JhcHBlcmBcbiAgICogdG8gdGhlIHJlZHVjZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIHJlZHVjZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHsqfSBpbml0aWFsVmFsdWUgLSB0aGUgaW5pdGlhbCB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHJlZHVjZShmbiwgaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROb2Rlc0ludGVybmFsKCkucmVkdWNlKFxuICAgICAgICAoYWNjdW0sIG4sIGkpID0+IGZuLmNhbGwodGhpcywgYWNjdW0sIHRoaXMud3JhcChuKSwgaSksXG4gICAgICAgIGluaXRpYWxWYWx1ZSxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldE5vZGVzSW50ZXJuYWwoKS5yZWR1Y2UoKGFjY3VtLCBuLCBpKSA9PiBmbi5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgIGkgPT09IDEgPyB0aGlzLndyYXAoYWNjdW0pIDogYWNjdW0sXG4gICAgICB0aGlzLndyYXAobiksXG4gICAgICBpLFxuICAgICkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZHVjZXMgdGhlIGN1cnJlbnQgYXJyYXkgb2Ygbm9kZXMgdG8gYW5vdGhlciBhcnJheSwgZnJvbSByaWdodCB0byBsZWZ0LiBFYWNoIG5vZGUgaXMgcGFzc2VkXG4gICAqIGluIGFzIGEgYFNoYWxsb3dXcmFwcGVyYCB0byB0aGUgcmVkdWNlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgcmVkdWNlciBmdW5jdGlvblxuICAgKiBAcGFyYW0geyp9IGluaXRpYWxWYWx1ZSAtIHRoZSBpbml0aWFsIHZhbHVlXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgcmVkdWNlUmlnaHQoZm4sIGluaXRpYWxWYWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpLnJlZHVjZVJpZ2h0KFxuICAgICAgICAoYWNjdW0sIG4sIGkpID0+IGZuLmNhbGwodGhpcywgYWNjdW0sIHRoaXMud3JhcChuKSwgaSksXG4gICAgICAgIGluaXRpYWxWYWx1ZSxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldE5vZGVzSW50ZXJuYWwoKS5yZWR1Y2VSaWdodCgoYWNjdW0sIG4sIGkpID0+IGZuLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgaSA9PT0gMSA/IHRoaXMud3JhcChhY2N1bSkgOiBhY2N1bSxcbiAgICAgIHRoaXMud3JhcChuKSxcbiAgICAgIGksXG4gICAgKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyB3cmFwcGVyIHdpdGggYSBzdWJzZXQgb2YgdGhlIG5vZGVzIG9mIHRoZSBvcmlnaW5hbCB3cmFwcGVyLCBhY2NvcmRpbmcgdG8gdGhlXG4gICAqIHJ1bGVzIG9mIGBBcnJheSNzbGljZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBiZWdpblxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIHNsaWNlKGJlZ2luLCBlbmQpIHtcbiAgICByZXR1cm4gdGhpcy53cmFwKHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpLnNsaWNlKGJlZ2luLCBlbmQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFueSBvZiB0aGUgbm9kZXMgaW4gdGhlIHdyYXBwZXIgbWF0Y2ggdGhlIHByb3ZpZGVkIHNlbGVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge0VuenltZVNlbGVjdG9yfSBzZWxlY3RvclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIHNvbWUoc2VsZWN0b3IpIHtcbiAgICBpZiAodGhpc1tST09UXSA9PT0gdGhpcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFsbG93V3JhcHBlcjo6c29tZSgpIGNhbiBub3QgYmUgY2FsbGVkIG9uIHRoZSByb290Jyk7XG4gICAgfVxuICAgIGNvbnN0IHByZWRpY2F0ZSA9IGJ1aWxkUHJlZGljYXRlKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gdGhpcy5nZXROb2Rlc0ludGVybmFsKCkuc29tZShwcmVkaWNhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW55IG9mIHRoZSBub2RlcyBpbiB0aGUgd3JhcHBlciBwYXNzIHRoZSBwcm92aWRlZCBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIHNvbWVXaGVyZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROb2Rlc0ludGVybmFsKCkuc29tZSgobiwgaSkgPT4gcHJlZGljYXRlLmNhbGwodGhpcywgdGhpcy53cmFwKG4pLCBpKSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhbGwgb2YgdGhlIG5vZGVzIGluIHRoZSB3cmFwcGVyIG1hdGNoIHRoZSBwcm92aWRlZCBzZWxlY3Rvci5cbiAgICpcbiAgICogQHBhcmFtIHtFbnp5bWVTZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBldmVyeShzZWxlY3Rvcikge1xuICAgIGNvbnN0IHByZWRpY2F0ZSA9IGJ1aWxkUHJlZGljYXRlKHNlbGVjdG9yKTtcbiAgICByZXR1cm4gdGhpcy5nZXROb2Rlc0ludGVybmFsKCkuZXZlcnkocHJlZGljYXRlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFueSBvZiB0aGUgbm9kZXMgaW4gdGhlIHdyYXBwZXIgcGFzcyB0aGUgcHJvdmlkZWQgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICBldmVyeVdoZXJlKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiB0aGlzLmdldE5vZGVzSW50ZXJuYWwoKS5ldmVyeSgobiwgaSkgPT4gcHJlZGljYXRlLmNhbGwodGhpcywgdGhpcy53cmFwKG4pLCBpKSk7XG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBtZXRob2QgdXNlZCB0byBjcmVhdGUgbmV3IHdyYXBwZXJzIHdpdGggYSBtYXBwaW5nIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheSBvZlxuICAgKiBub2RlcyBpbiByZXNwb25zZSB0byBhIHNpbmdsZSBub2RlIHdyYXBwZXIuIFRoZSByZXR1cm5lZCB3cmFwcGVyIGlzIGEgc2luZ2xlIHdyYXBwZXIgYXJvdW5kXG4gICAqIGFsbCBvZiB0aGUgbWFwcGVkIG5vZGVzIGZsYXR0ZW5lZCAoYW5kIGRlLWR1cGxpY2F0ZWQpLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcmV0dXJucyB7U2hhbGxvd1dyYXBwZXJ9XG4gICAqL1xuICBmbGF0TWFwKGZuKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLmdldE5vZGVzSW50ZXJuYWwoKS5tYXAoKG4sIGkpID0+IGZuLmNhbGwodGhpcywgdGhpcy53cmFwKG4pLCBpKSk7XG4gICAgY29uc3QgZmxhdHRlbmVkID0gZmxhdChub2RlcywgMSk7XG4gICAgcmV0dXJuIHRoaXMud3JhcChmbGF0dGVuZWQuZmlsdGVyKEJvb2xlYW4pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgbm9kZXMgaW4gdGhlIGN1cnJlbnQgd3JhcHBlciBub2RlcycgcmVuZGVyIHRyZWVzIHRoYXQgbWF0Y2ggdGhlIHByb3ZpZGVkIHByZWRpY2F0ZVxuICAgKiBmdW5jdGlvbi4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIG5vZGVzIGluc2lkZSBhIFNoYWxsb3dXcmFwcGVyIGFzIGl0c1xuICAgKiBmaXJzdCBhcmd1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIGZpbmRXaGVyZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZmluZFdoZXJlVW53cmFwcGVkKHRoaXMsIChuKSA9PiB7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy53cmFwKG4pO1xuICAgICAgcmV0dXJuIG5vZGUubGVuZ3RoID4gMCAmJiBwcmVkaWNhdGUobm9kZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbm9kZSBhdCBhIGdpdmVuIGluZGV4IG9mIHRoZSBjdXJyZW50IHdyYXBwZXIuXG4gICAqXG4gICAqIEBwYXJhbSBpbmRleFxuICAgKiBAcmV0dXJucyB7UmVhY3RFbGVtZW50fVxuICAgKi9cbiAgZ2V0KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHMoKVtpbmRleF07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBub2RlIGF0IGEgZ2l2ZW4gaW5kZXggb2YgdGhlIGN1cnJlbnQgd3JhcHBlci5cbiAgICpcbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIGF0KGluZGV4KSB7XG4gICAgY29uc3Qgbm9kZXMgPSB0aGlzLmdldE5vZGVzSW50ZXJuYWwoKTtcbiAgICBpZiAoaW5kZXggPCBub2Rlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLndyYXAobm9kZXNbaW5kZXhdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMud3JhcChbXSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBmaXJzdCBub2RlIG9mIHRoZSBjdXJyZW50IHdyYXBwZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIGZpcnN0KCkge1xuICAgIHJldHVybiB0aGlzLmF0KDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgbGFzdCBub2RlIG9mIHRoZSBjdXJyZW50IHdyYXBwZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIGxhc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXQodGhpcy5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxlZ2F0ZXMgdG8gZXhpc3RzKClcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0VtcHR5KCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZS53YXJuKCdFbnp5bWU6OkRlcHJlY2F0ZWQgbWV0aG9kIGlzRW1wdHkoKSBjYWxsZWQsIHVzZSBleGlzdHMoKSBpbnN0ZWFkLicpO1xuICAgIHJldHVybiAhdGhpcy5leGlzdHMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgd3JhcHBlciBoYXMgbm9kZXMuIEZhbHNlIG90aGVyd2lzZS5cbiAgICogSWYgY2FsbGVkIHdpdGggYSBzZWxlY3RvciBpdCByZXR1cm5zIGAuZmluZChzZWxlY3RvcikuZXhpc3RzKClgIGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RW56eW1lU2VsZWN0b3J9IHNlbGVjdG9yIChvcHRpb25hbClcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBleGlzdHMoc2VsZWN0b3IgPSBudWxsKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gdGhpcy5maW5kKHNlbGVjdG9yKS5leGlzdHMoKSA6IHRoaXMubGVuZ3RoID4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IG1ldGhvZCB0aGF0IHRocm93cyBhbiBlcnJvciBpZiB0aGUgY3VycmVudCBpbnN0YW5jZSBoYXMgYSBsZW5ndGggb3RoZXIgdGhhbiBvbmUuXG4gICAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gZW5mb3JjZSB0aGF0IGNlcnRhaW4gbWV0aG9kcyBhcmUgb25seSBydW4gb24gYSB3cmFwcGVyIHdoZW4gaXQgaXNcbiAgICogd3JhcHBpbmcgYSBzaW5nbGUgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIGZuXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgc2luZ2xlKG5hbWUsIGZuKSB7XG4gICAgY29uc3QgZm5OYW1lID0gdHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnID8gbmFtZSA6ICd1bmtub3duJztcbiAgICBjb25zdCBjYWxsYmFjayA9IHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyA/IGZuIDogbmFtZTtcbiAgICBpZiAodGhpcy5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWV0aG9kIOKAnCR7Zm5OYW1lfeKAnSBpcyBtZWFudCB0byBiZSBydW4gb24gMSBub2RlLiAke3RoaXMubGVuZ3RofSBmb3VuZCBpbnN0ZWFkLmApO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLmdldE5vZGVJbnRlcm5hbCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZnVsIHV0aWxpdHkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyB3cmFwcGVyIHdpdGggdGhlIHNhbWUgcm9vdCBhcyB0aGUgY3VycmVudCB3cmFwcGVyLCB3aXRoXG4gICAqIGFueSBub2RlcyBwYXNzZWQgaW4gYXMgdGhlIGZpcnN0IHBhcmFtZXRlciBhdXRvbWF0aWNhbGx5IHdyYXBwZWQuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIHdyYXAobm9kZSwgcm9vdCA9IHRoaXNbUk9PVF0sIC4uLmFyZ3MpIHtcbiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIFNoYWxsb3dXcmFwcGVyKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTaGFsbG93V3JhcHBlcihub2RlLCByb290LCAuLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIEhUTUwtbGlrZSBzdHJpbmcgb2YgdGhlIHNoYWxsb3cgcmVuZGVyIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBQcm9wZXJ0eSBiYWcgb2YgYWRkaXRpb25hbCBvcHRpb25zLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZVByb3BzXSAtIGlmIHRydWUsIHByb3BzIGFyZSBvbWl0dGVkIGZyb20gdGhlIHN0cmluZy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy52ZXJib3NlXSAtIGlmIHRydWUsIGFycmF5cyBhbmQgb2JqZWN0cyB0byBiZSB2ZXJib3NlbHkgcHJpbnRlZC5cbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIGRlYnVnKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBkZWJ1Z05vZGVzKHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGludGVyY2VwdGVyIGFuZCByZXR1cm5zIGl0c2VsZi4gaW50ZXJjZXB0ZXIgaXMgY2FsbGVkIHdpdGggaXRzZWxmLlxuICAgKiBUaGlzIGlzIGhlbHBmdWwgd2hlbiBkZWJ1Z2dpbmcgbm9kZXMgaW4gbWV0aG9kIGNoYWlucy5cbiAgICogQHBhcmFtIGZuXG4gICAqIEByZXR1cm5zIHtTaGFsbG93V3JhcHBlcn1cbiAgICovXG4gIHRhcChpbnRlcmNlcHRlcikge1xuICAgIGludGVyY2VwdGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaW1hcmlseSB1c2VmdWwgZm9yIEhPQ3MgKGhpZ2hlci1vcmRlciBjb21wb25lbnRzKSwgdGhpcyBtZXRob2QgbWF5IG9ubHkgYmVcbiAgICogcnVuIG9uIGEgc2luZ2xlLCBub24tRE9NIG5vZGUsIGFuZCB3aWxsIHJldHVybiB0aGUgbm9kZSwgc2hhbGxvdy1yZW5kZXJlZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHJldHVybnMge1NoYWxsb3dXcmFwcGVyfVxuICAgKi9cbiAgZGl2ZShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcih0aGlzW09QVElPTlNdKTtcbiAgICBjb25zdCBuYW1lID0gJ2RpdmUnO1xuICAgIHJldHVybiB0aGlzLnNpbmdsZShuYW1lLCAobikgPT4ge1xuICAgICAgaWYgKG4gJiYgbi5ub2RlVHlwZSA9PT0gJ2hvc3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFNoYWxsb3dXcmFwcGVyOjoke25hbWV9KCkgY2FuIG5vdCBiZSBjYWxsZWQgb24gSG9zdCBDb21wb25lbnRzYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBlbCA9IGdldEFkYXB0ZXIodGhpc1tPUFRJT05TXSkubm9kZVRvRWxlbWVudChuKTtcbiAgICAgIGlmICghaXNDdXN0b21Db21wb25lbnRFbGVtZW50KGVsLCBhZGFwdGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBTaGFsbG93V3JhcHBlcjo6JHtuYW1lfSgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiBjb21wb25lbnRzYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZE9wdGlvbnMgPSBtYWtlSW5oZXJpdGVkQ2hpbGRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMud3JhcChlbCwgbnVsbCwgY2hpbGRPcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHJpcHMgb3V0IGFsbCB0aGUgbm90IGhvc3Qtbm9kZXMgZnJvbSB0aGUgbGlzdCBvZiBub2Rlc1xuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gY2hlY2sgZm9yIHRoZSBwcmVzZW5jZSBvZiBob3N0IG5vZGVzXG4gICAqIChhY3R1YWxseSByZW5kZXJlZCBIVE1MIGVsZW1lbnRzKSBpZ25vcmluZyB0aGUgUmVhY3Qgbm9kZXMuXG4gICAqL1xuICBob3N0Tm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyV2hlcmUoKG4pID0+IHR5cGVvZiBuLnR5cGUoKSA9PT0gJ3N0cmluZycpO1xuICB9XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgY29udGV4dCBvZiB0aGUgcHJpbWFyeSB3cmFwcGVyIHdoZW4gdGhlXG4gKiBgd3JhcHBpbmdDb21wb25lbnRgIHJlLXJlbmRlcnMuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVByaW1hcnlSb290Q29udGV4dCh3cmFwcGluZ0NvbXBvbmVudCkge1xuICBjb25zdCBhZGFwdGVyID0gZ2V0QWRhcHRlcih3cmFwcGluZ0NvbXBvbmVudFtPUFRJT05TXSk7XG4gIGNvbnN0IHByaW1hcnlXcmFwcGVyID0gd3JhcHBpbmdDb21wb25lbnRbUFJJTUFSWV9XUkFQUEVSXTtcbiAgY29uc3QgcHJpbWFyeVJlbmRlcmVyID0gcHJpbWFyeVdyYXBwZXJbUkVOREVSRVJdO1xuICBjb25zdCBwcmltYXJ5Tm9kZSA9IHByaW1hcnlSZW5kZXJlci5nZXROb2RlKCk7XG4gIGNvbnN0IHtcbiAgICBsZWdhY3lDb250ZXh0LFxuICAgIHByb3ZpZGVyVmFsdWVzLFxuICB9ID0gZ2V0Q29udGV4dEZyb21XcmFwcGluZ0NvbXBvbmVudCh3cmFwcGluZ0NvbXBvbmVudCwgYWRhcHRlcik7XG4gIGNvbnN0IHByZXZQcm92aWRlclZhbHVlcyA9IHByaW1hcnlXcmFwcGVyW1BST1ZJREVSX1ZBTFVFU107XG5cbiAgcHJpbWFyeVdyYXBwZXIuc2V0Q29udGV4dCh7XG4gICAgLi4ud3JhcHBpbmdDb21wb25lbnRbUFJJTUFSWV9XUkFQUEVSXVtPUFRJT05TXS5jb250ZXh0LFxuICAgIC4uLmxlZ2FjeUNvbnRleHQsXG4gIH0pO1xuICBwcmltYXJ5V3JhcHBlcltQUk9WSURFUl9WQUxVRVNdID0gbmV3IE1hcChbLi4ucHJldlByb3ZpZGVyVmFsdWVzLCAuLi5wcm92aWRlclZhbHVlc10pO1xuXG4gIGlmICh0eXBlb2YgYWRhcHRlci5pc0NvbnRleHRDb25zdW1lciA9PT0gJ2Z1bmN0aW9uJyAmJiBhZGFwdGVyLmlzQ29udGV4dENvbnN1bWVyKHByaW1hcnlOb2RlLnR5cGUpKSB7XG4gICAgY29uc3QgQ29uc3VtZXIgPSBwcmltYXJ5Tm9kZS50eXBlO1xuICAgIC8vIEFkYXB0ZXJzIHdpdGggYW4gYGlzQ29udGV4dENvbnN1bWVyYCBtZXRob2Qgd2lsbCBkZWZpbml0ZWx5IGhhdmUgYSBgZ2V0UHJvdmlkZXJGcm9tQ29uc3VtZXJgXG4gICAgLy8gbWV0aG9kLlxuICAgIGNvbnN0IFByb3ZpZGVyID0gYWRhcHRlci5nZXRQcm92aWRlckZyb21Db25zdW1lcihDb25zdW1lcik7XG4gICAgY29uc3QgbmV3VmFsdWUgPSBwcm92aWRlclZhbHVlcy5nZXQoUHJvdmlkZXIpO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gcHJldlByb3ZpZGVyVmFsdWVzLmdldChQcm92aWRlcik7XG5cbiAgICAvLyBVc2UgcmVmZXJlbnRpYWwgY29tcGFyaXNvbiBsaWtlIFJlYWN0XG4gICAgaWYgKG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgcHJpbWFyeVdyYXBwZXIucmVyZW5kZXIoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBICpzcGVjaWFsKiBcInJvb3RcIiB3cmFwcGVyIHRoYXQgcmVwcmVzZW50cyB0aGUgY29tcG9uZW50IHBhc3NlZCBhcyBgd3JhcHBpbmdDb21wb25lbnRgLlxuICogSXQgaXMgbGlua2VkIHRvIHRoZSBwcmltYXJ5IHJvb3Qgc3VjaCB0aGF0IHVwZGF0ZXMgdG8gaXQgd2lsbCB1cGRhdGUgdGhlIHByaW1hcnkuXG4gKlxuICogQGNsYXNzIFdyYXBwaW5nQ29tcG9uZW50V3JhcHBlclxuICovXG5jbGFzcyBXcmFwcGluZ0NvbXBvbmVudFdyYXBwZXIgZXh0ZW5kcyBTaGFsbG93V3JhcHBlciB7XG4gIGNvbnN0cnVjdG9yKG5vZGVzLCByb290LCBSb290RmluZGVyKSB7XG4gICAgc3VwZXIobm9kZXMpO1xuICAgIHByaXZhdGVTZXQodGhpcywgUFJJTUFSWV9XUkFQUEVSLCByb290KTtcbiAgICBwcml2YXRlU2V0KHRoaXMsIFJPT1RfRklOREVSLCBSb290RmluZGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaWtlIHJlcmVuZGVyKCkgb24gU2hhbGxvd1dyYXBwZXIsIGV4Y2VwdCBpdCBhbHNvIGRvZXMgYSBcImZ1bGwgcmVuZGVyXCIgb2ZcbiAgICogaXRzZWxmIGFuZCB1cGRhdGVzIHRoZSBwcmltYXJ5IFNoYWxsb3dXcmFwcGVyJ3MgY29udGV4dC5cbiAgICovXG4gIHJlcmVuZGVyKC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5yZXJlbmRlciguLi5hcmdzKTtcbiAgICB1cGRhdGVQcmltYXJ5Um9vdENvbnRleHQodGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaWtlIHNldFN0YXRlKCkgb24gU2hhbGxvd1dyYXBwZXIsIGV4Y2VwdCBpdCBhbHNvIGRvZXMgYSBcImZ1bGwgcmVuZGVyXCIgb2ZcbiAgICogaXRzZWxmIGFuZCB1cGRhdGVzIHRoZSBwcmltYXJ5IFNoYWxsb3dXcmFwcGVyJ3MgY29udGV4dC5cbiAgICovXG4gIHNldFN0YXRlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5zZXRTdGF0ZSguLi5hcmdzKTtcbiAgICB1cGRhdGVQcmltYXJ5Um9vdENvbnRleHQodGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIGdldFdyYXBwaW5nQ29tcG9uZW50KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hhbGxvd1dyYXBwZXI6OmdldFdyYXBwaW5nQ29tcG9uZW50KCkgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoZSByb290Jyk7XG4gIH1cbn1cblxuaWYgKElURVJBVE9SX1NZTUJPTCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hhbGxvd1dyYXBwZXIucHJvdG90eXBlLCBJVEVSQVRPUl9TWU1CT0wsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGl0ZXJhdG9yKCkge1xuICAgICAgY29uc3QgaXRlciA9IHRoaXMuZ2V0Tm9kZXNJbnRlcm5hbCgpW0lURVJBVE9SX1NZTUJPTF0oKTtcbiAgICAgIGNvbnN0IGFkYXB0ZXIgPSBnZXRBZGFwdGVyKHRoaXNbT1BUSU9OU10pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW0lURVJBVE9SX1NZTUJPTF0oKSB7IHJldHVybiB0aGlzOyB9LFxuICAgICAgICBuZXh0KCkge1xuICAgICAgICAgIGNvbnN0IG5leHQgPSBpdGVyLm5leHQoKTtcbiAgICAgICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBhZGFwdGVyLm5vZGVUb0VsZW1lbnQobmV4dC52YWx1ZSksXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByaXZhdGVXYXJuaW5nKHByb3AsIGV4dHJhTWVzc2FnZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU2hhbGxvd1dyYXBwZXIucHJvdG90eXBlLCBwcm9wLCB7XG4gICAgZ2V0KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBcbiAgICAgICAgQXR0ZW1wdGVkIHRvIGFjY2VzcyBTaGFsbG93V3JhcHBlcjo6JHtwcm9wfSwgd2hpY2ggd2FzIHByZXZpb3VzbHkgYSBwcml2YXRlIHByb3BlcnR5IG9uXG4gICAgICAgIEVuenltZSBTaGFsbG93V3JhcHBlciBpbnN0YW5jZXMsIGJ1dCBpcyBubyBsb25nZXIgYW5kIHNob3VsZCBub3QgYmUgcmVsaWVkIHVwb24uXG4gICAgICAgICR7ZXh0cmFNZXNzYWdlfVxuICAgICAgYCk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICB9KTtcbn1cblxucHJpdmF0ZVdhcm5pbmcoJ25vZGUnLCAnQ29uc2lkZXIgdXNpbmcgdGhlIGdldEVsZW1lbnQoKSBtZXRob2QgaW5zdGVhZC4nKTtcbnByaXZhdGVXYXJuaW5nKCdub2RlcycsICdDb25zaWRlciB1c2luZyB0aGUgZ2V0RWxlbWVudHMoKSBtZXRob2QgaW5zdGVhZC4nKTtcbnByaXZhdGVXYXJuaW5nKCdyZW5kZXJlcicsICcnKTtcbnByaXZhdGVXYXJuaW5nKCdvcHRpb25zJywgJycpO1xucHJpdmF0ZVdhcm5pbmcoJ2NvbXBsZXhTZWxlY3RvcicsICcnKTtcblxuZXhwb3J0IGRlZmF1bHQgU2hhbGxvd1dyYXBwZXI7XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUFBLGVBQUEsR0FBQUMsT0FBQTs7QUFDQSxJQUFBQyxJQUFBLEdBQUFELE9BQUE7O0FBQ0EsSUFBQUUsbUJBQUEsR0FBQUYsT0FBQTs7QUFFQSxJQUFBRyxNQUFBLEdBQUFILE9BQUE7QUFtQkEsSUFBQUksV0FBQSxHQUFBSixPQUFBOztBQUNBLElBQUFLLE1BQUEsR0FBQUwsT0FBQTtBQUNBLElBQUFNLGFBQUEsR0FBQU4sT0FBQTtBQVFBLElBQUFPLFVBQUEsR0FBQVAsT0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTVEsSUFBQSxHQUFPLElBQUFMLE1BQUEsQ0FBQU0sR0FBQSxFQUFJLFVBQUosQ0FBYjtBQUNBLElBQU1DLEtBQUEsR0FB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